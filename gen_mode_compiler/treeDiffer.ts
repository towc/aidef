import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Normalizes .gen.aid content for comparison.
 * Removes comments, leading/trailing whitespace, and collapses multiple newlines.
 * @param content The raw .gen.aid file content.
 * @returns Normalized content string.
 */
export function normalizeAidContent(content: string): string {
  // Remove single-line comments (// ...) and multi-line comments (/* ... */)
  let normalized = content.replace(/\/\/.*$/gm, ''); // Single-line comments
  normalized = normalized.replace(/\/\*[\s\S]*?\*\//g, ''); // Multi-line comments

  // Remove leading/trailing whitespace from each line and collapse multiple newlines
  normalized = normalized
    .split('\\n')
    .map(line => line.trim())
    .filter(line => line.length > 0) // Remove empty lines
    .join('\\n');

  return normalized;
}

/**
 * Checks if two .gen.aid file contents are practically equivalent.
 * @param oldContent The existing .gen.aid file content.
 * @param newContent The new .gen.aid file content.
 * @returns True if contents are equivalent after normalization, false otherwise.
 */
export function areAidFilesEquivalent(oldContent: string, newContent: string): boolean {
  return normalizeAidContent(oldContent) === normalizeAidContent(newContent);
}

/**
 * Recursively prunes a branch by deleting files listed in leaf.gen.aid.leaf.json files.
 * It only deletes files that were explicitly listed as generated by a leaf.
 * It also deletes empty directories created by the gen mode.
 * @param branchPath The path to the branch directory to prune.
 */
export async function pruneBranch(branchPath: string): Promise<void> {
  try {
    const entries = await fs.readdir(branchPath, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(branchPath, entry.name);

      if (entry.isDirectory()) {
        // Recursively prune subdirectories
        await pruneBranch(entryPath);

        // After pruning children, check if the directory is empty and delete it
        try {
          const subDirEntries = await fs.readdir(entryPath);
          if (subDirEntries.length === 0) {
            await fs.rmdir(entryPath);
            console.log(`Deleted empty directory: ${entryPath}`);
          }
        } catch (err: any) {
          if (err.code === 'ENOENT') {
            // Directory already gone, ignore
          } else {
            console.warn(`Could not check or delete directory ${entryPath}: ${err.message}`);
          }
        }
      } else if (entry.isFile() && entry.name === 'leaf.gen.aid.leaf.json') {
        // This is a leaf configuration file, read it to find files to delete
        try {
          const leafConfigContent = await fs.readFile(entryPath, 'utf-8');
          const leafConfig = JSON.parse(leafConfigContent);
          if (leafConfig.files && Array.isArray(leafConfig.files)) {
            for (const fileToDelete of leafConfig.files) {
              const filePath = path.join(path.dirname(entryPath), fileToDelete);
              try {
                await fs.unlink(filePath);
                console.log(`Deleted generated file: ${filePath}`);
              } catch (err: any) {
                if (err.code === 'ENOENT') {
                  // File already gone, ignore
                } else {
                  console.warn(`Could not delete file ${filePath}: ${err.message}`);
                }
              }
            }
          }
          // Also delete the leaf config file itself
          await fs.unlink(entryPath);
          console.log(`Deleted leaf config file: ${entryPath}`);
        } catch (err) {
          console.error(`Error processing leaf config ${entryPath}: ${err}`);
        }
      } else if (entry.isFile() && entry.name === 'node.gen.aid') {
        // Do not delete node.gen.aid files here, they are managed by the compiler logic
        // when a node's content changes.
      }
    }
  } catch (err: any) {
    if (err.code === 'ENOENT') {
      // Branch path does not exist, nothing to prune. This is fine.
      console.log(`Branch path ${branchPath} does not exist, no pruning needed.`);
    } else {
      console.error(`Error pruning branch ${branchPath}: ${err}`);
      throw err;
    }
  }
}
