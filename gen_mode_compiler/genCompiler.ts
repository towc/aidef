import * as fs from 'fs/promises';
import * as path from 'path';
import { genNode } from './nodeGenerator';
import { genLeaf } from './leafGenerator';
import { areAidFilesEquivalent, pruneBranch } from './treeDiffer';

// Placeholder for a parser module. In a real scenario, this would parse the .gen.aid syntax.
// For now, we'll treat the .gen.aid content as a string that the LLM interprets.
// If the .gen.aid file has a specific syntax, a parser would be needed here.
// For this exercise, the LLM is expected to "parse" it and respond with tool calls.
async function readAidFile(filePath: string): Promise<string> {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      console.warn(`File not found: ${filePath}. Treating as empty.`);
      return ''; // Return empty string if file doesn't exist, useful for initial generation
    }
    throw error;
  }
}

interface GenCompilerConfig {
  maxRetries: number;
  temperature: number; // Should be 0 or very low for predictability
}

// Define the structure for LLM tool calls
interface ToolCall {
  name: string;
  args: { [key: string]: any };
}

// Placeholder for LLM interaction. In a real system, this would call an actual LLM API.
// It should take the system prompt, user content, tools, and temperature.
// For this exercise, it will return a hardcoded set of tool calls.
async function callLLM(
  systemPrompt: string,
  userContent: string,
  tools: any[], // Simplified tool definition for placeholder
  temperature: number
): Promise<{ toolCalls: ToolCall[] }> {
  console.log('--- Simulating LLM Call ---');
  console.log('System Prompt:', systemPrompt);
  console.log('User Content (AID):', userContent);
  console.log('Tools:', tools.map(t => t.name).join(', '));
  console.log('Temperature:', temperature);
  console.log('---------------------------');

  // Simulate a response based on the userContent.
  // In a real scenario, the LLM would analyze `userContent` and decide which tools to call.
  // For demonstration, let's assume it always tries to create a child node and a leaf.
  // A more sophisticated simulation might parse `userContent` for keywords.

  if (userContent.includes('create_example_node')) {
    return {
      toolCalls: [
        {
          name: 'gen_node',
          args: {
            name: 'example_child_node',
            content: `
              // This is a child node spec generated by the LLM
              // It could contain further instructions for its own children
              create_example_leaf_in_child
            `,
          },
        },
        {
          name: 'gen_leaf',
          args: {
            name: 'root_readme_leaf',
            prompt: 'Generate a root README.md file for the project.',
            files: ['README.md'],
            commands: null,
          },
        },
      ],
    };
  } else if (userContent.includes('create_example_leaf_in_child')) {
    return {
      toolCalls: [
        {
          name: 'gen_leaf',
          args: {
            name: 'child_component_leaf',
            prompt: 'Generate a simple TypeScript component file.',
            files: ['src/component.ts', 'src/component.test.ts'],
            commands: ['npm install', 'npm test'],
          },
        },
      ],
    };
  } else {
    // Default response if no specific keywords are found
    return {
      toolCalls: [
        {
          name: 'gen_leaf',
          args: {
            name: 'default_leaf',
            prompt: 'Generate a default output file.',
            files: ['output.txt'],
            commands: null,
          },
        },
      ],
    };
  }
}


export class GenCompiler {
  constructor(private config: GenCompilerConfig) {
    if (this.config.temperature > 0.1) { // Enforce low temperature
      console.warn(`Temperature set to ${this.config.temperature}. For predictability, it's recommended to use a very low temperature (e.g., 0 or 0.01).`);
    }
  }

  /**
   * Compiles a .gen.aid file, generating child nodes and leaves.
   * @param aidFilePath The path to the .gen.aid file to compile.
   * @param currentDirPath The current directory path where children should be created.
   */
  async compile(aidFilePath: string, currentDirPath: string): Promise<void> {
    console.log(`Compiling: ${aidFilePath} in directory: ${currentDirPath}`);

    const aidContent = await readAidFile(aidFilePath);

    const systemPrompt = `
      You are an AI assistant tasked with generating code project structures based on a .gen.aid specification.
      Your goal is to break down the given specification into child nodes (sub-specifications) or leaf nodes (concrete code generation tasks).
      Use the provided tools: 'gen_node' to create a child node with its own .gen.aid specification, and 'gen_leaf' to create a leaf node for direct file generation.
      Each node and leaf will reside in its own dedicated folder.
      Ensure that the content you provide for 'gen_node' is a valid .gen.aid specification.
      For 'gen_leaf', provide a clear prompt, a list of files to be generated, and optional shell commands.
      Do not generate any other output apart from tool calls.
      The current .gen.aid content is:
      '''
      ${aidContent}
      '''
    `;

    const tools = [
      {
        name: 'gen_node',
        description: 'Creates a child node at ./<node_name>/node.gen.aid. The content is the .aid specification for the child.',
        parameters: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the child node folder.' },
            content: { type: 'string', description: 'The .aid specification for the child node.' },
          },
          required: ['name', 'content'],
        },
      },
      {
        name: 'gen_leaf',
        description: 'Creates a leaf node at ./<leaf_name>/leaf.gen.aid.leaf.json. The prompt contains instructions, files lists files to create, and commands are shell commands.',
        parameters: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the leaf node folder.' },
            prompt: { type: 'string', description: 'Instructions for the leaf node generation.' },
            files: { type: 'array', items: { type: 'string' }, description: 'List of files to be created by this leaf.' },
            commands: { type: 'array', items: { type: 'string' }, description: 'Optional shell commands to run.' },
          },
          required: ['name', 'prompt', 'files'],
        },
      },
    ];

    let retries = 0;
    while (retries <= this.config.maxRetries) {
      try {
        const llmResponse = await callLLM(systemPrompt, aidContent, tools, this.config.temperature);

        if (!llmResponse || !llmResponse.toolCalls || llmResponse.toolCalls.length === 0) {
          console.log(`LLM returned no tool calls for ${aidFilePath}.`);
          break; // Nothing to do, consider it a success for this node.
        }

        for (const toolCall of llmResponse.toolCalls) {
          if (toolCall.name === 'gen_node') {
            const { name, content } = toolCall.args;
            const childNodeDirPath = path.join(currentDirPath, name);
            const childAidFilePath = path.join(childNodeDirPath, 'node.gen.aid');

            let existingChildAidContent = '';
            try {
              existingChildAidContent = await fs.readFile(childAidFilePath, 'utf-8');
            } catch (err: any) {
              if (err.code !== 'ENOENT') {
                console.error(`Error reading existing child node AID file ${childAidFilePath}: ${err}`);
                throw err;
              }
            }

            if (areAidFilesEquivalent(existingChildAidContent, content)) {
              console.log(`Node '${name}' .gen.aid content is equivalent. Skipping recursion for this branch.`);
              // If equivalent, we don't prune or regenerate, just ensure the node exists and move on.
              // The existing children are kept.
              await genNode(name, existingChildAidContent, currentDirPath); // Ensure directory and file exist
              // No recursion needed as content is equivalent, existing children are preserved.
            } else {
              console.log(`Node '${name}' .gen.aid content changed or is new. Pruning existing branch and recursing.`);
              // Prune the existing branch before generating new content
              await pruneBranch(childNodeDirPath);
              // Generate the new node.gen.aid file
              const newChildNodeDirPath = await genNode(name, content, currentDirPath);
              // Recurse into the newly (or re-)generated node
              await this.compile(childAidFilePath, newChildNodeDirPath);
            }
          } else if (toolCall.name === 'gen_leaf') {
            const { name, prompt, files, commands } = toolCall.args;
            await genLeaf(name, prompt, files, commands, currentDirPath);
          } else {
            console.warn(`Unknown tool call: ${toolCall.name}`);
          }
        }
        break; // Success, exit retry loop
      } catch (error) {
        console.error(`Compilation failed for ${aidFilePath}, retry ${retries + 1}/${this.config.maxRetries}:`, error);
        retries++;
        if (retries > this.config.maxRetries) {
          throw new Error(`Max retries (${this.config.maxRetries}) exceeded for ${aidFilePath}. Last error: ${error}`);
        }
        // Add a small delay before retrying to prevent hammering the LLM (if it were real)
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
}
