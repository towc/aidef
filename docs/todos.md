# AIDef Implementation TODOs

## Current State

The MVP foundation is complete. All core components work with nginx-like syntax.

### Completed Phases

#### Phase 1: Parser ✅
- [x] Lexer: identifiers, braces, strings, numbers, semicolons, equals, include keyword
- [x] Comments: `/* */` and `//` (stripped from output)
- [x] Code blocks: ``` (preserved as literal prose)
- [x] Line/column tracking for error messages
- [x] AST: module blocks `name { }`, query filters `"question?" { }`, parameters, prose
- [x] Import resolution: `include ./path;` with cycle detection
- [x] 159 tests passing

#### Phase 2: CLI Skeleton ✅
- [x] `aid` - entry point, finds root.aid in current directory
- [x] `aid --help` - usage info
- [x] `aid --auth` - LLM provider configuration (stub TUI)
- [x] `aid --browse` - stub (prints "not implemented")
- [x] `aid --build` - stub
- [x] `aid --estimate` - stub
- [x] `aid --verbose` - debug output

#### Phase 3: Provider Abstraction ✅
- [x] Provider interface definition
- [x] Anthropic adapter via Vercel AI SDK
- [x] OpenAI adapter via Vercel AI SDK
- [x] Config loading: env vars (`ANTHROPIC_API_KEY`, `OPENAI_API_KEY`)
- [x] Connection testing
- [x] Call logging to `.aid-gen/calls.jsonl`

#### Phase 4: Single-Node Compilation ✅
- [x] Compile one node with provider
- [x] Generate `.aidg` output
- [x] Generate `.aidc` output (YAML)
- [x] Generate `.aidq` output (YAML) for questions
- [x] Write to `.aid-gen/`

#### Phase 5: Recursive Compilation ✅
- [x] Walk tree, compile each node
- [x] Pass context from parent to child
- [x] Parallel execution of siblings
- [x] Progress reporting

---

## Current Phase: Incremental Builds

### Phase 6: Context Filtering
Simple approach for MVP:
- [x] Pass full `.aidc` to AI
- [ ] Token budget: trim oldest ancestry first if over limit
- [ ] Track source file origin for each rule in `.aidc`
- [ ] Future: Multi-pass regeneration if context missing

### Phase 7: Diffing & Incremental Builds (Current)
- [ ] Define interface hash structure
- [ ] Hash interfaces for comparison
- [ ] Compare new vs existing `.aidg`
- [ ] Skip unchanged subtrees
- [ ] Report what changed
- [ ] Cache invalidation rules

### Phase 8: Build Phase (Code Generation)
- [ ] Execute leaf nodes
- [ ] Generate code to `build/`
- [ ] Parallel leaf execution
- [ ] Add source module comment header to generated files
  - Detect file extension, add appropriate comment syntax
  - Include module path (e.g., `// Generated by: server/api`)
  - Enables traceability: `build/` file → module → `.aidc` → original `.aid` files

### Phase 9: TUI (`--browse`)
- [ ] Tree view of `.aid-gen/` structure
- [ ] View node content
- [ ] View/answer `.aidq` questions
- [ ] View `.aids` suggestions for each module
- [ ] Apply suggestions
- [ ] Trigger build
- [ ] Abort compilation

### Phase 10: Analysis & Suggestions (`--analyze`)
- [ ] `aid --analyze` command to analyze compiled structure
- [ ] Generate `.aids` files (AI suggestions) for optimization
- [ ] Analyze AI thought process from `calls.jsonl`
- [ ] Identify shortcuts: where AI iterated or explored multiple options
- [ ] Suggest additions to original `.aid` files to reduce future compile time/tokens

### Phase 11: Polish
- [ ] `--estimate` implementation
- [ ] Better error messages
- [ ] Documentation site
- [ ] npm/bun package publishing

---

## Syntax Reference (nginx-like)

### Hardcoded Patterns
| Pattern | Meaning |
|---------|---------|
| `name { }` | Module block |
| `"question?" { }` | Query filter block (LLM-evaluated) |
| `include ./path;` | Import file |
| `/* */` | Block comment |
| `//` | Line comment |
| `;` | Statement terminator |

### Parameters
Inside blocks: `param="value";` or `param=123;`

Recognized parameters:
- `leaf="reason"` - don't subdivide this module
- `never="reason"` - forbid this submodule  
- `optional="reason"` - may be skipped
- `priority=1` - compilation order (lower first)
- `path="./src"` - output path override
- `model="opus"` - LLM model override

Unrecognized parameters: warning, passed to AI as context.

### Example
```
/*
  Task Manager API
*/

A simple REST API for managing tasks.

TypeScript strict mode;
Zod for validation;

shared {
  AppError: base error class;
  db: database connection singleton;
}

server {
  leaf=true;
  Bun.serve() setup;
  Route mounting;
}

"needs database access?" {
  Include connection pooling;
  Handle transactions;
}
```

---

## Design Decisions

### LLM Provider
Using **Vercel AI SDK** (`ai` package) with `@ai-sdk/*` providers:
- Multi-provider support out of the box
- Battle-tested, well-maintained

Current providers:
- `@ai-sdk/anthropic` (Claude) - primary
- `@ai-sdk/openai` (GPT) - secondary

### Determinism
True determinism is impossible with LLMs, but we maximize consistency:
- `temperature: 0`
- Structured prompts with clear output format
- Interface enforcement catches drift
- Diffing skips unchanged subtrees

### Testing Strategy

**Deterministic tests** (run always, no API costs):
- Unit tests: Lexer, parser, import resolution
- Mock AI responses for integration tests
- Located in `tests/unit/` and `tests/integration/`

**Non-deterministic tests** (run manually, requires API keys):
- Real LLM calls with curated test cases
- Located in `tests/e2e/`
- Skipped by default

```bash
bun test              # unit + integration only (159 tests)
bun test tests/e2e    # real AI calls (manual)
```

### Submodule Placement
When specifying a submodule in `.aid` files, it doesn't have to be a direct child - it just needs to exist somewhere in the subtree of the parent with the same semantic meaning. The generator has flexibility in how it structures the actual code hierarchy.

---

## Interfaces

### Types (in `src/types/index.ts`)

Key types for nginx-like syntax:
- `Token`, `TokenType` - Lexer output
- `ModuleNode`, `QueryFilterNode`, `ProseNode`, `ParameterNode`, `IncludeNode` - AST nodes
- `NodeContext` - Context passed to children (`.aidc` content)
- `Provider`, `CompileRequest`, `CompileResult` - LLM abstraction
- `CallLogEntry` - AI call tracking

---

## Questions Resolved

1. **Module names cannot have spaces** - simplifies parsing, use hyphens instead (`email-service`)

2. **Import scoping**: `include` inside a block scopes content under that block

3. **Error recovery**: Collect multiple errors, continue parsing

4. **Streaming**: Stream progress as nodes complete

5. **Full traceability chain**: `build/` file → module → `.aidc` → original `.aid` files
   - Each generated file gets a comment header with the generating module path
   - `.aidc` tracks which original `.aid` files contributed each rule

---

## File Structure

```
aidef/
├── src/
│   ├── types/index.ts      # All type definitions
│   ├── parser/
│   │   ├── lexer.ts        # Tokenizer
│   │   ├── ast.ts          # AST parser
│   │   ├── resolver.ts     # Import resolution
│   │   └── index.ts        # Exports
│   ├── compiler/
│   │   ├── compile-node.ts # Node compilation
│   │   ├── context-builder.ts
│   │   ├── writer.ts       # File output
│   │   └── index.ts
│   ├── providers/
│   │   ├── anthropic.ts
│   │   ├── openai.ts
│   │   ├── provider.ts     # Base interface
│   │   ├── call-logger.ts
│   │   └── index.ts
│   └── cli/
│       ├── index.ts        # Entry point
│       └── commands/*.ts
├── tests/
│   ├── unit/               # Lexer, AST, resolver tests
│   └── integration/        # Compiler tests with mocks
├── docs/                   # Documentation
├── examples/root.aid       # Example spec
├── root.aid                # AIDef's own spec (meta)
├── .aid-gen/               # Generated compilation output (gitignored)
└── build/                  # Generated code (gitignored)
```
