runtime {
  path=src/runtime;

  Executes the compiled plan by running all leaf nodes in parallel.
  
  For each leaf, the runtime:
    1. Reads the .leaf.json file
    2. Runs any whitelisted commands in the leaf's commands array
    3. Generates files listed in the leaf's files array using AI
    4. All work happens within the leaf's folder context
  
  Exports a run function that takes outputDir and apiKey.
  Finds all leaf.json files, executes them in parallel with progress reporting.

  leafExecutor {
    path=src/runtime/leafExecutor.ts;

    Executes a single leaf node.
    
    Exports LeafConfig interface and executeLeaf function.
    Runs whitelisted commands, then calls Gemini to generate files.
    Uses the write_file tool to create each file specified in the leaf.
  }

  commandWhitelist {
    path=src/runtime/commandWhitelist.ts;

    Leaf nodes can request shell commands, but only whitelisted ones run.
    Users can configure additional allowed commands in .aidrc or project config.
    The analyse mode suggests new commands to whitelist based on what leaves tried to run.
    
    Exports DEFAULT_WHITELIST array and isAllowed function.
    Default allows: npm init, npm install, npm ci, bun init, bun install, bun add.
  }

  logger {
    path=src/runtime/logger.ts;

    Stores all AI calls and command executions in runtime.log.jsonl.
    Each line is a JSON object with timestamp, type, leaf path, and details.
    Used by analyse mode to review what happened.
    
    Exports LogEntry interface and createLogger function.
  }
}
