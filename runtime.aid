runtime {
  path=src/runtime;

  Executes the compiled plan by running all leaf nodes in parallel.
  
  For each leaf, the runtime:
    1. Reads the .leaf.json file
    2. Creates the outputPath directory if needed
    3. Runs any whitelisted commands in that directory
    4. Generates files listed in files array, writing them to outputPath
  
  Exports a run function that takes outputDir and apiKey.
  Finds all leaf.json files, executes them in parallel with progress reporting.

  leafExecutor {
    Executes a single leaf node.
    
    Exports LeafConfig interface (with outputPath field) and executeLeaf function.
    
    The outputPath field tells us where to write files, relative to the project root.
    Commands run in the outputPath directory.
    Files are written to outputPath (e.g., if outputPath is src/compiler and files is [parser.ts], writes to src/compiler/parser.ts).
    
    Uses Gemini with a write_file tool to generate each file.
  }

  commandWhitelist {
    Leaf nodes can request shell commands, but only whitelisted ones run.
    Users can configure additional allowed commands in .aidrc or project config.
    The analyse mode suggests new commands to whitelist based on what leaves tried to run.
    
    Exports DEFAULT_WHITELIST array and isAllowed function.
    Default allows: bun init, bun install, bun add.
  }

  logger {
    Stores all AI calls and command executions in runtime.log.jsonl.
    Each line is a JSON object with timestamp, type, leaf path, and details.
    Used by analyse mode to review what happened.
    
    Exports LogEntry interface and createLogger function.
  }
}
