/**
 * Tree Differ
 * 
 * Compares .gen.aid files to determine if recompilation is needed.
 * Key for incremental compilation - skip unchanged branches.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import * as crypto from 'node:crypto';

export class TreeDiffer {
  /**
   * Compute a hash of .aid content for comparison.
   * Normalizes whitespace and removes comments for stable comparison.
   */
  hash(content: string): string {
    const normalized = this.normalize(content);
    return crypto.createHash('sha256').update(normalized).digest('hex').slice(0, 16);
  }

  /**
   * Check if a node has changed compared to its previous version.
   * Returns true if unchanged (can skip recompilation).
   */
  isUnchanged(oldContent: string, newContent: string): boolean {
    return this.hash(oldContent) === this.hash(newContent);
  }

  /**
   * Load the previous version of a .gen.aid file if it exists.
   * Previous versions are stored as .gen.aid.prev
   */
  loadPrevious(genAidPath: string): string | null {
    const prevPath = genAidPath + '.prev';
    try {
      return fs.readFileSync(prevPath, 'utf-8');
    } catch {
      return null;
    }
  }

  /**
   * Save the current version as the previous version for future diffing.
   */
  savePrevious(genAidPath: string, content: string): void {
    const prevPath = genAidPath + '.prev';
    fs.writeFileSync(prevPath, content, 'utf-8');
  }

  /**
   * Collect all files that would be generated by leaves in a directory tree.
   * Used to know what to prune when a branch changes.
   */
  collectLeafFiles(dir: string): string[] {
    const files: string[] = [];
    
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          files.push(...this.collectLeafFiles(fullPath));
        } else if (entry.name.endsWith('.leaf.json')) {
          try {
            const leaf = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));
            if (Array.isArray(leaf.files)) {
              const leafDir = path.dirname(fullPath);
              for (const file of leaf.files) {
                files.push(path.join(leafDir, file));
              }
            }
          } catch {
            // Invalid JSON, skip
          }
        }
      }
    } catch {
      // Directory doesn't exist
    }
    
    return files;
  }

  /**
   * Prune a branch - delete only the files that were generated by leaves.
   * Preserves user files like .env, config files, etc.
   */
  pruneBranch(dir: string): void {
    const filesToDelete = this.collectLeafFiles(dir);
    
    for (const file of filesToDelete) {
      try {
        if (fs.existsSync(file)) {
          fs.unlinkSync(file);
          console.log(`[diff] Pruned ${file}`);
        }
      } catch (error) {
        console.warn(`[diff] Failed to prune ${file}:`, error);
      }
    }

    // Also delete .gen.aid files and .leaf.json files
    this.deleteGenFiles(dir);
  }

  /**
   * Delete all .gen.aid and .leaf.json files in a directory tree.
   */
  private deleteGenFiles(dir: string): void {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          this.deleteGenFiles(fullPath);
          // Try to remove empty directory
          try {
            fs.rmdirSync(fullPath);
          } catch {
            // Not empty, that's fine
          }
        } else if (
          entry.name.endsWith('.gen.aid') ||
          entry.name.endsWith('.gen.aid.prev') ||
          entry.name.endsWith('.leaf.json')
        ) {
          fs.unlinkSync(fullPath);
          console.log(`[diff] Deleted ${fullPath}`);
        }
      }
    } catch {
      // Directory doesn't exist
    }
  }

  /**
   * Normalize content for comparison:
   * - Trim each line
   * - Remove empty lines
   * - Remove comment lines
   * - Sort lines (order shouldn't matter for semantic equivalence)
   */
  private normalize(content: string): string {
    return content
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)
      .filter(line => !line.startsWith('#'))
      .join('\n');
  }
}
