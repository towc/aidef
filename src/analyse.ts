// Generated by aidef. Edit root.aid to change behavior.

interface AnalyseOptions {
  output: string;
  apiKey: string;
}

interface AidMap {
  generatedFile: string;
  generatedLine: number;
  originalFile: string;
  originalLine: number;
}

interface AidInfo {
  callId: string;
  timestamp: string;
  model: string;
  prompt: string;
  response: string;
  durationMs: number;
  success: boolean;
  error?: string;
  instructionId?: string;
}

interface InstructionFlowGraphNode {
  id: string;
  type: 'parent' | 'child' | 'leaf';
  aidFile: string;
  originalLine: number;
  generatedFile?: string;
  generatedLine?: number;
  contentSnippet: string;
}

interface InstructionFlowGraphEdge {
  from: string;
  to: string;
  type: 'generates' | 'calls' | 'dependsOn';
}

interface InstructionFlowGraph {
  nodes: InstructionFlowGraphNode[];
  edges: InstructionFlowGraphEdge[];
}

interface AnalysisIssue {
  type: 'miscommunication' | 'inefficiency' | 'slowResponse' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  relatedNodeIds?: string[];
  relatedAidInfoIds?: string[];
  suggestedFix?: string;
}

interface AnalysisReport {
  summary: string;
  issues: AnalysisIssue[];
  performanceMetrics: {
    totalCalls: number;
    failedCalls: number;
    avgDurationMs: number;
    maxDurationMs: number;
  };
  flowGraphId?: string;
  infoDataIds?: string[];
}

interface Suggestion {
  id: string;
  description: string;
  targetFile: string;
  targetLine?: number;
  amendmentType: 'insert' | 'replace' | 'delete' | 'modify';
  amendmentContent: string;
  contextSnippet: string;
  relatedIssueIds?: string[];
  recursiveOrigin?: {
    originalSuggestionId: string;
    derivedFromNodeId: string;
  };
  status?: 'pending' | 'applied' | 'rejected';
}

async function readJsonFile<T>(filePath: string): Promise<T | null> {
  try {
    const file = Bun.file(filePath);
    const content = await file.text();
    return JSON.parse(content) as T;
  } catch (error) {
    console.error(`Error reading or parsing file ${filePath}:`, error);
    return null;
  }
}

async function writeJsonFile(filePath: string, data: any): Promise<void> {
  try {
    await Bun.write(filePath, JSON.stringify(data, null, 2));
  } catch (error) {
    console.error(`Error writing file ${filePath}:`, error);
  }
}

async function loadPlanMaps(outputDir: string): Promise<AidMap[]> {
  const maps: AidMap[] = [];
  const glob = new Bun.Glob('*.gen.aid.map');
  for await (const file of glob.scan({ cwd: outputDir })) {
    const filePath = `${outputDir}/${file}`;
    const map = await readJsonFile<AidMap>(filePath);
    if (map) {
      maps.push(map);
    }
  }
  return maps;
}

async function loadAnalysisInfo(outputDir: string): Promise<AidInfo[]> {
  const infos: AidInfo[] = [];
  const glob = new Bun.Glob('*.gen.aid.info');
  for await (const file of glob.scan({ cwd: outputDir })) {
    const filePath = `${outputDir}/${file}`;
    const info = await readJsonFile<AidInfo>(filePath);
    if (info) {
      infos.push(info);
    }
  }
  return infos;
}

function buildInstructionFlowGraph(mapData: AidMap[]): InstructionFlowGraph {
  const nodes = new Map<string, InstructionFlowGraphNode>();
  const edges: InstructionFlowGraphEdge[] = [];
  const generates = new Map<string, string[]>();
  const generatedBy = new Map<string, string[]>();

  for (const map of mapData) {
    const originalNodeId = `${map.originalFile}:${map.originalLine}`;
    const generatedNodeId = `${map.generatedFile}:${map.generatedLine}`;

    if (!nodes.has(originalNodeId)) {
      nodes.set(originalNodeId, {
        id: originalNodeId,
        type: 'leaf',
        aidFile: map.originalFile,
        originalLine: map.originalLine,
        contentSnippet: `// Content from ${map.originalFile}:${map.originalLine}`
      });
    }

    if (!nodes.has(generatedNodeId)) {
      nodes.set(generatedNodeId, {
        id: generatedNodeId,
        type: 'leaf',
        aidFile: map.generatedFile,
        originalLine: map.generatedLine,
        generatedFile: map.generatedFile,
        generatedLine: map.generatedLine,
        contentSnippet: `// Content from ${map.generatedFile}:${map.generatedLine}`
      });
    }

    edges.push({ from: originalNodeId, to: generatedNodeId, type: 'generates' });

    if (!generates.has(originalNodeId)) generates.set(originalNodeId, []);
    generates.get(originalNodeId)!.push(generatedNodeId);

    if (!generatedBy.has(generatedNodeId)) generatedBy.set(generatedNodeId, []);
    generatedBy.get(generatedNodeId)!.push(originalNodeId);
  }

  for (const node of nodes.values()) {
    const hasOutgoing = generates.has(node.id) && generates.get(node.id)!.length > 0;
    const hasIncoming = generatedBy.has(node.id) && generatedBy.get(node.id)!.length > 0;

    if (hasOutgoing) {
      node.type = 'parent';
    } else if (hasIncoming) {
      node.type = 'child';
    }
  }

  return { nodes: Array.from(nodes.values()), edges };
}

function evaluatePerformanceAndCommunication(flowGraph: InstructionFlowGraph, infoData: AidInfo[]): AnalysisReport {
  const totalCalls = infoData.length;
  let failedCalls = 0;
  let totalDurationMs = 0;
  let maxDurationMs = 0;
  const issues: AnalysisIssue[] = [];

  for (const info of infoData) {
    totalDurationMs += info.durationMs;
    if (info.durationMs > maxDurationMs) maxDurationMs = info.durationMs;

    if (!info.success) {
      failedCalls++;
      issues.push({
        type: 'miscommunication',
        severity: 'high',
        description: `AI call ${info.callId} failed: ${info.error || 'Unknown error'}`,
        relatedAidInfoIds: [info.callId],
        suggestedFix: 'Review the prompt and context for this AI call.'
      });
    }

    if (info.durationMs > 5000 && info.success) {
      issues.push({
        type: 'slowResponse',
        severity: 'medium',
        description: `AI call ${info.callId} took ${info.durationMs}ms.`,
        relatedAidInfoIds: [info.callId],
        suggestedFix: 'Consider optimizing the prompt or using a faster model.'
      });
    }
  }

  const avgDurationMs = totalCalls > 0 ? totalDurationMs / totalCalls : 0;

  let summary = `Analysis Report: ${totalCalls} AI calls, ${failedCalls} failed. Average duration: ${avgDurationMs.toFixed(2)}ms.`;
  if (failedCalls > 0) summary += ' Critical issues found related to failed AI calls.';
  if (issues.some(i => i.type === 'slowResponse')) summary += ' Some AI calls exhibited slow response times.';

  return {
    summary,
    issues,
    performanceMetrics: { totalCalls, failedCalls, avgDurationMs, maxDurationMs },
    infoDataIds: infoData.map(i => i.callId)
  };
}

function generateRefinementSuggestions(report: AnalysisReport, mapData: AidMap[]): Suggestion[] {
  const suggestions: Suggestion[] = [];
  let counter = 0;

  for (const issue of report.issues) {
    if (issue.relatedAidInfoIds) {
      for (const callId of issue.relatedAidInfoIds) {
        suggestions.push({
          id: `sug-${++counter}`,
          description: `${issue.type === 'miscommunication' ? 'Refine prompt' : 'Optimize performance'}: ${issue.description}`,
          targetFile: 'root.aid',
          amendmentType: 'modify',
          amendmentContent: issue.suggestedFix || '',
          contextSnippet: issue.description,
          relatedIssueIds: [issue.description]
        });
      }
    }
  }
  return suggestions;
}

async function saveSuggestions(suggestions: Suggestion[], outputDir: string): Promise<void> {
  for (const suggestion of suggestions) {
    const filePath = `${outputDir}/suggestion-${suggestion.id}.json`;
    await writeJsonFile(filePath, suggestion);
  }
}

export async function analyse(options: AnalyseOptions): Promise<void> {
  console.log(`Starting analysis with output directory: ${options.output}`);

  const mapData = await loadPlanMaps(options.output);
  console.log(`Loaded ${mapData.length} plan maps.`);

  const infoData = await loadAnalysisInfo(options.output);
  console.log(`Loaded ${infoData.length} analysis info entries.`);

  const flowGraph = buildInstructionFlowGraph(mapData);
  console.log(`Built instruction flow graph with ${flowGraph.nodes.length} nodes and ${flowGraph.edges.length} edges.`);

  const report = evaluatePerformanceAndCommunication(flowGraph, infoData);
  console.log(`Generated analysis report: ${report.summary}`);

  const suggestions = generateRefinementSuggestions(report, mapData);
  console.log(`Generated ${suggestions.length} refinement suggestions.`);

  await saveSuggestions(suggestions, options.output);
  console.log(`Saved suggestions to ${options.output}.`);

  console.log('Analysis complete.');
}
