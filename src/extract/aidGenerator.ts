// Generated by aidef. Edit extract.aid to change behavior.
import { GoogleGenAI } from '@google/genai';
import type { ProjectFile, ScanResult } from './scanner';
import type { ModuleInfo, ProjectAnalysis } from './analyzer';

// Type definitions (COPY THESE EXACTLY)
interface ProjectFile {
  relativePath: string;
  content: string;
  extension: string;
  sizeBytes: number;
}

interface ScanResult {
  rootPath: string;
  files: ProjectFile[];
  totalFiles: number;
  totalBytes: number;
}

interface ModuleInfo {
  name: string;
  path: string;
  description: string;
  children: ModuleInfo[];
  keyExports: string[];
}

interface ProjectAnalysis {
  projectName: string;
  description: string;
  language: string;
  runtime: string;
  modules: ModuleInfo[];
  dependencies: string[];
}

export interface AidOutput {
  rootAid: string;
  includes: Map<string, string>;
}

function formatModuleInfo(module: ModuleInfo, indent: string = ''): string {
  let result = `${indent}- Module: ${module.name}
`;
  result += `${indent}  Path: ${module.path}
`;
  result += `${indent}  Description: ${module.description}
`;
  if (module.keyExports && module.keyExports.length > 0) {
    result += `${indent}  Key Exports: ${module.keyExports.join(', ')}
`;
  }
  if (module.children && module.children.length > 0) {
    result += `${indent}  Children:
`;
    for (const child of module.children) {
      result += formatModuleInfo(child, indent + '    ');
    }
  }
  return result;
}

export async function generateAid(analysis: ProjectAnalysis, scanResult: ScanResult, apiKey: string): Promise<AidOutput> {
  const genai = new GoogleGenAI({ apiKey });

  let modulesDescription = '';
  for (const module of analysis.modules) {
    modulesDescription += formatModuleInfo(module);
  }

  const prompt = `
You are an AI assistant that generates .aid files for software projects.
Your task is to create a high-level architectural description of a project in the .aid format.
The output should be a JSON object with two fields:
- \`rootAid\`: A string containing the content of the main \`root.aid\` file.
- \`includes\`: An object where keys are filenames (e.g., "module_name.aid") and values are strings containing the content of those include files.

Follow these rules for generating the .aid content:
1.  **Top-level Prose**: Start with a general description of the project.
2.  **Module Blocks**: Use \`module "ModuleName" { ... }\` syntax.
3.  **Path Parameter**: Inside module blocks, use \`path="relative/path/to/module"\` for the main file/directory of the module.
4.  **Nested Modules**: Represent sub-modules as nested module blocks.
5.  **Include Statements**: If the project has 5 or more top-level modules, split major modules into separate include files. In \`root.aid\`, use \`include "filename.aid"\` to reference them. The content of these included files should be placed in the \`includes\` object.
6.  **Content**: Describe WHAT the module does, not HOW it does it. Keep it abstract and descriptive, NOT code.
7.  **Preserve Specifics**: Include important details like package names, API patterns, model names, and port numbers.
8.  **JSON Format**: Ensure the entire output is a valid JSON object.

Here is the project analysis:
Project Name: ${analysis.projectName}
Description: ${analysis.description}
Language: ${analysis.language}
Runtime: ${analysis.runtime}
Dependencies: ${analysis.dependencies.join(', ')}

Modules:
${modulesDescription}

File Scan Summary:
Total Files: ${scanResult.totalFiles}
Total Bytes: ${scanResult.totalBytes}

Generate the JSON output.
`;

  const response = await genai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: [{ role: 'user', parts: [{ text: prompt }] }],
    config: { temperature: 0.3 }
  });

  const text = response.text;

  let parsedOutput: { rootAid: string; includes: { [key: string]: string } };
  try {
    parsedOutput = JSON.parse(text);
  } catch (error) {
    console.error('Failed to parse LLM response as JSON:', error);
    console.error('LLM response:', text);
    // Fallback: if parsing fails, assume the LLM just returned rootAid content
    // and no includes. This is a simplification and might not always be correct.
    return {
      rootAid: text,
      includes: new Map<string, string>()
    };
  }

  return {
    rootAid: parsedOutput.rootAid,
    includes: new Map(Object.entries(parsedOutput.includes || {}))
  };
}
