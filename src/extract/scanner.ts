// Generated by aidef. Edit extract.aid to change behavior.
import * as fs from 'node:fs/promises';
import * as path from 'node:path';

export interface ProjectFile {
  relativePath: string;
  content: string;
  extension: string;
  sizeBytes: number;
}

export interface ScanResult {
  rootPath: string;
  files: ProjectFile[];
  totalFiles: number;
  totalBytes: number;
}

const MAX_FILE_SIZE_BYTES = 100 * 1024; // 100KB
const BINARY_CHECK_BYTES = 512;

const COMMON_SKIP_DIRS = new Set([
  'node_modules',
  '.git',
  'dist',
  'build',
  'coverage',
  '__pycache__',
  '.next',
  '.vscode',
  '.idea',
  '.DS_Store',
  'Thumbs.db',
]);

const COMMON_SKIP_FILES = new Set([
  '.gitignore',
  'package-lock.json',
  'yarn.lock',
  'pnpm-lock.yaml',
]);

function isBinary(buffer: Uint8Array): boolean {
  for (let i = 0; i < buffer.length; i++) {
    if (buffer[i] === 0) {
      return true; // Null byte found, likely binary
    }
  }
  return false;
}

function getFileExtension(filename: string): string {
  return path.extname(filename);
}

async function readGitignorePatterns(dirPath: string): Promise<string[]> {
  const gitignorePath = path.join(dirPath, '.gitignore');
  try {
    const content = await Bun.file(gitignorePath).text();
    return content
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line && !line.startsWith('#')); // Filter out comments and empty lines
  } catch (error) {
    // .gitignore not found or unreadable
    return [];
  }
}

// A very basic .gitignore pattern matcher.
// This is not a full implementation of .gitignore spec.
// It handles simple file/directory names and basic '*' wildcards at the end.
function matchesGitignorePattern(relativePath: string, patterns: string[]): boolean {
  const relativePathNormalized = relativePath.replace(/\\/g, '/'); // Normalize path separators for matching

  for (const pattern of patterns) {
    let effectivePattern = pattern.replace(/\\/g, '/'); // Normalize pattern separators

    // Handle directory patterns (ending with /)
    if (effectivePattern.endsWith('/')) {
      const dirPattern = effectivePattern.slice(0, -1);
      // Match if the relativePath is the directory itself or starts with the directory path
      if (relativePathNormalized === dirPattern || relativePathNormalized.startsWith(dirPattern + '/')) {
        return true;
      }
    } else {
      // Handle file patterns or general patterns
      // Exact match
      if (relativePathNormalized === effectivePattern) {
        return true;
      }
      // Match if the relativePath ends with the pattern (e.g., "foo/bar.txt" matches "bar.txt")
      if (relativePathNormalized.endsWith('/' + effectivePattern)) {
        return true;
      }
      // Basic wildcard at the end (e.g., *.log)
      if (effectivePattern.startsWith('*') && effectivePattern.length > 1) {
        const suffix = effectivePattern.substring(1);
        if (relativePathNormalized.endsWith(suffix)) {
          return true;
        }
      }
    }
  }
  return false;
}

export async function scan(targetPath: string): Promise<ScanResult> {
  const files: ProjectFile[] = [];
  let totalBytes = 0;
  let totalFiles = 0;

  const stats = await fs.stat(targetPath);
  const rootPath = path.resolve(targetPath);

  if (stats.isFile()) {
    const fileContent = await Bun.file(targetPath).arrayBuffer();
    const buffer = new Uint8Array(fileContent);

    if (buffer.byteLength > MAX_FILE_SIZE_BYTES || isBinary(buffer.slice(0, BINARY_CHECK_BYTES))) {
      return { rootPath, files: [], totalFiles: 0, totalBytes: 0 };
    }

    const content = new TextDecoder().decode(buffer);
    const relativePath = path.relative(rootPath, targetPath);

    files.push({
      relativePath: relativePath === '' ? path.basename(targetPath) : relativePath,
      content,
      extension: getFileExtension(targetPath),
      sizeBytes: buffer.byteLength,
    });
    totalFiles = 1;
    totalBytes = buffer.byteLength;

    return { rootPath, files, totalFiles, totalBytes };

  } else if (stats.isDirectory()) {
    const visitedDirs = new Set<string>();

    async function walk(currentAbsolutePath: string, currentRelativePath: string, inheritedGitignorePatterns: string[]) {
      if (visitedDirs.has(currentAbsolutePath)) {
        return;
      }
      visitedDirs.add(currentAbsolutePath);

      // Check against common skip directories
      const currentDirName = path.basename(currentAbsolutePath);
      if (COMMON_SKIP_DIRS.has(currentDirName)) {
        return;
      }

      let currentGitignorePatterns = [...inheritedGitignorePatterns];
      const localGitignore = await readGitignorePatterns(currentAbsolutePath);
      if (localGitignore.length > 0) {
        currentGitignorePatterns = [...currentGitignorePatterns, ...localGitignore];
      }

      const entries = await fs.readdir(currentAbsolutePath, { withFileTypes: true });

      for (const entry of entries) {
        const entryAbsolutePath = path.join(currentAbsolutePath, entry.name);
        const entryRelativePath = path.join(currentRelativePath, entry.name);

        // Check against common skip files
        if (entry.isFile() && COMMON_SKIP_FILES.has(entry.name)) {
          continue;
        }

        // Check against .gitignore patterns
        if (matchesGitignorePattern(entryRelativePath, currentGitignorePatterns)) {
          continue;
        }

        if (entry.isDirectory()) {
          await walk(entryAbsolutePath, entryRelativePath, currentGitignorePatterns);
        } else if (entry.isFile()) {
          try {
            const fileStats = await fs.stat(entryAbsolutePath);

            if (fileStats.size > MAX_FILE_SIZE_BYTES) {
              continue;
            }

            const fileContentBuffer = await Bun.file(entryAbsolutePath).arrayBuffer();
            const buffer = new Uint8Array(fileContentBuffer);

            if (isBinary(buffer.slice(0, BINARY_CHECK_BYTES))) {
              continue;
            }

            const content = new TextDecoder().decode(buffer);

            files.push({
              relativePath: entryRelativePath,
              content,
              extension: getFileExtension(entry.name),
              sizeBytes: fileStats.size,
            });
            totalFiles++;
            totalBytes += fileStats.size;

          } catch (fileError) {
            // console.warn(`Could not read file ${entryAbsolutePath}:`, fileError);
          }
        }
      }
    }

    await walk(rootPath, '', []); // Start walking from the root path with empty relative path and no inherited patterns

    return { rootPath, files, totalFiles, totalBytes };

  } else {
    return { rootPath, files: [], totalFiles: 0, totalBytes: 0 };
  }
}
