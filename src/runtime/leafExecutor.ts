// Generated by aidef. Edit compiler.aid to change behavior.
// PRE-EXISTING: Import necessary types and functions from siblings
import { isAllowed } from './commandWhitelist';
import { Logger, LogEntry } from './logger';
import { GoogleGenAI, Type } from '@google/genai';
import * as path from 'path';
import * as fs from 'node:fs/promises';

// Type definitions for imported interfaces (copied for clarity to the child)
export interface Logger { log: (entry: LogEntry) => void; }
export interface LogEntry { timestamp: string; type: 'ai_call' | 'command_execution' | 'file_write'; leafPath: string; details: any; }

// Export interface GenLeaf
export interface GenLeaf {
    path: string;
    dir: string;
    outputPath: string;
    sourceAid: string;
    prompt: string;
    files: string[];
    commands?: string[];
}

/**
 * Executes a GenLeaf, running commands and generating files using Google Gemini.
 * @param leaf The GenLeaf to execute.
 * @param apiKey The Google Gemini API key.
 * @param outputDir The base output directory for generated files.
 * @param logger The logger instance for logging events.
 */
export async function executeLeaf(leaf: GenLeaf, apiKey: string, outputDir: string, logger: Logger): Promise<void> {
    // 1. First, run any commands from 'leaf.commands'.
    if (leaf.commands && leaf.commands.length > 0) {
        for (const command of leaf.commands) {
            // Use the 'isAllowed' function from './commandWhitelist' to check if a command is whitelisted.
            if (!isAllowed(command)) {
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'blocked', reason: 'Command not whitelisted' },
                });
                throw new Error(`Command not allowed: ${command}`);
            }

            // Log each command execution using the provided 'logger'.
            logger.log({
                timestamp: new Date().toISOString(),
                type: 'command_execution',
                leafPath: leaf.path,
                details: { command, status: 'executing' },
            });

            try {
                // Execute the command using Bun.spawn
                const proc = Bun.spawn(command.split(' '));
                const stdout = await new Response(proc.stdout).text();
                const stderr = await new Response(proc.stderr).text();
                const exitCode = await proc.exit;

                if (exitCode !== 0) {
                    throw new Error(`Command failed with exit code ${exitCode}: ${stderr}`);
                }

                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'success', stdout, stderr, exitCode },
                });
            } catch (error: any) {
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'failed', error: error.message },
                });
                throw new Error(`Failed to execute command '${command}': ${error.message}`);
            }
        }
    }

    // 2. Use '@google/genai' (Google Gemini) to generate each file.
    // Initialize GoogleGenAI with the provided 'apiKey'.
    const genAI = new GoogleGenAI({ apiKey });

    // Define write_file tool
    const writeFileTool = {
        name: 'write_file',
        description: 'Write content to a file. Use this tool to create each requested file.',
        parameters: {
            type: Type.OBJECT,
            properties: {
                path: { type: Type.STRING, description: 'File path (relative to leaf output directory)' },
                content: { type: Type.STRING, description: 'Complete file content' },
            },
            required: ['path', 'content'],
        },
    };

    // Build the prompt with file list
    const fileList = leaf.files.map(f => `- ${f}`).join('\n');
    const prompt = `${leaf.prompt}

Files to create:
${fileList}

You MUST use the write_file function to create each file. Call write_file once for each file listed above.`;

    const filesToGenerate = new Set(leaf.files);
    const generatedFiles = new Set<string>();

    // Conversation history for multi-turn
    const history: Array<{role: 'user' | 'model' | 'function', parts: Array<{text?: string, functionCall?: any, functionResponse?: any}>}> = [];

    let attempts = 0;
    const MAX_ATTEMPTS = 10;

    // Initial request
    logger.log({
        timestamp: new Date().toISOString(),
        type: 'ai_call',
        leafPath: leaf.path,
        details: { prompt, type: 'initial_prompt' },
    });

    history.push({ role: 'user', parts: [{ text: prompt }] });

    while (generatedFiles.size < filesToGenerate.size && attempts < MAX_ATTEMPTS) {
        attempts++;

        // Make the API call (using gemini-2.5-flash for function calling stability)
        const response = await genAI.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: history,
            config: { 
                temperature: 0,
                tools: [{ functionDeclarations: [writeFileTool] }]
            }
        });

        // Check for function calls
        if (response.functionCalls && response.functionCalls.length > 0) {
            // Add model response to history
            history.push({ 
                role: 'model', 
                parts: response.functionCalls.map(fc => ({ functionCall: { name: fc.name, args: fc.args } }))
            });

            const functionResponses: Array<{functionResponse: {name: string, response: any}}> = [];

            for (const call of response.functionCalls) {
                if (call.name === 'write_file') {
                    const { path: filePath, content } = call.args as { path: string, content: string };

                    if (!filePath || typeof filePath !== 'string' || !content || typeof content !== 'string') {
                        functionResponses.push({
                            functionResponse: { name: 'write_file', response: { error: 'Invalid arguments' } }
                        });
                        continue;
                    }

                    const fullPath = path.join(outputDir, leaf.outputPath, filePath);
                    const dirPath = path.dirname(fullPath);

                    try {
                        await fs.mkdir(dirPath, { recursive: true });
                        await fs.writeFile(fullPath, content);

                        generatedFiles.add(filePath);

                        logger.log({
                            timestamp: new Date().toISOString(),
                            type: 'file_write',
                            leafPath: leaf.path,
                            details: { filePath, fullPath, size: content.length },
                        });

                        functionResponses.push({
                            functionResponse: { name: 'write_file', response: { status: 'success', path: fullPath } }
                        });
                    } catch (error: any) {
                        console.error(`Error writing file ${fullPath}:`, error);
                        functionResponses.push({
                            functionResponse: { name: 'write_file', response: { status: 'failed', error: error.message } }
                        });
                    }
                }
            }

            // Add function responses to history
            history.push({ role: 'function', parts: functionResponses });

        } else {
            // No function calls - model might need prompting
            if (generatedFiles.size < filesToGenerate.size) {
                const remainingFiles = Array.from(filesToGenerate).filter(f => !generatedFiles.has(f));
                const followUp = `Please use the write_file function to create these remaining files: ${remainingFiles.join(', ')}`;
                
                // Add model's text response if any
                if (response.text) {
                    history.push({ role: 'model', parts: [{ text: response.text }] });
                }
                
                history.push({ role: 'user', parts: [{ text: followUp }] });
                
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'ai_call',
                    leafPath: leaf.path,
                    details: { prompt: followUp, type: 'follow_up' },
                });
            } else {
                break;
            }
        }
    }

    // Final check
    if (generatedFiles.size < filesToGenerate.size) {
        const unwrittenFiles = Array.from(filesToGenerate).filter(f => !generatedFiles.has(f));
        logger.log({
            timestamp: new Date().toISOString(),
            type: 'ai_call',
            leafPath: leaf.path,
            details: { status: 'failed', reason: 'Not all files generated', unwrittenFiles, attempts },
        });
        throw new Error(`Missing files after ${attempts} attempts: ${unwrittenFiles.join(', ')}`);
    }

    logger.log({
        timestamp: new Date().toISOString(),
        type: 'ai_call',
        leafPath: leaf.path,
        details: { status: 'success', attempts },
    });
}
