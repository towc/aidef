// Generated by aidef. Edit compiler.aid to change behavior.
// PRE-EXISTING: Import necessary types and functions from siblings
import { isAllowed } from './commandWhitelist';
import { Logger, LogEntry } from './logger';
import { GoogleGenAI } from '@google/genai';
import * as path from 'path'; // Use node:path for cross-platform compatibility

// Type definitions for imported interfaces (copied for clarity to the child)
export interface Logger { log: (entry: LogEntry) => void; }
export interface LogEntry { timestamp: string; type: 'ai_call' | 'command_execution' | 'file_write'; leafPath: string; details: any; }

// Export interface GenLeaf
export interface GenLeaf {
    path: string;
    dir: string;
    outputPath: string;
    sourceAid: string;
    prompt: string;
    files: string[];
    commands?: string[];
}

/**
 * Executes a GenLeaf, running commands and generating files using Google Gemini.
 * @param leaf The GenLeaf to execute.
 * @param apiKey The Google Gemini API key.
 * @param outputDir The base output directory for generated files.
 * @param logger The logger instance for logging events.
 */
export async function executeLeaf(leaf: GenLeaf, apiKey: string, outputDir: string, logger: Logger): Promise<void> {
    // 1. First, run any commands from 'leaf.commands'.
    if (leaf.commands && leaf.commands.length > 0) {
        for (const command of leaf.commands) {
            // Use the 'isAllowed' function from './commandWhitelist' to check if a command is whitelisted.
            if (!isAllowed(command)) {
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'blocked', reason: 'Command not whitelisted' },
                });
                throw new Error(`Command not allowed: ${command}`);
            }

            // Log each command execution using the provided 'logger'.
            logger.log({
                timestamp: new Date().toISOString(),
                type: 'command_execution',
                leafPath: leaf.path,
                details: { command, status: 'executing' },
            });

            try {
                // Execute the command using Bun.spawn
                const proc = Bun.spawn(command.split(' '));
                const stdout = await new Response(proc.stdout).text();
                const stderr = await new Response(proc.stderr).text();
                const exitCode = await proc.exit;

                if (exitCode !== 0) {
                    throw new Error(`Command failed with exit code ${exitCode}: ${stderr}`);
                }

                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'success', stdout, stderr, exitCode },
                });
            } catch (error: any) {
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'command_execution',
                    leafPath: leaf.path,
                    details: { command, status: 'failed', error: error.message },
                });
                throw new Error(`Failed to execute command '${command}': ${error.message}`);
            }
        }
    }

    // 2. Use '@google/genai' (Google Gemini) to generate each file.
    // Initialize GoogleGenAI with the provided 'apiKey'.
    const genAI = new GoogleGenAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

    // Define the 'write_file' tool.
    const write_file_tool = {
        name: 'write_file',
        description: 'Write content to a file',
        parameters: {
            type: 'object',
            properties: {
                path: { type: 'string', description: 'File path (relative to leaf output directory)' },
                content: { type: 'string', description: 'Complete file content' },
            },
            required: ['path', 'content'],
        },
    };

    // Use the chat model with a 'write_file' tool.
    const chat = model.startChat({
        tools: [write_file_tool],
    });

    // The prompt sent to the LLM should include:
    // - 'leaf.prompt' (the code generation instructions provided by the leaf).
    // - A clear list of files to create (from 'leaf.files').
    // - The instruction: "Use the write_file tool to create each file."
    const fileList = leaf.files.map(f => `- ${f}`).join('\n');
    const initialPrompt = `${leaf.prompt}

Files to create:
${fileList}

Use the write_file tool to create each file.`;

    const filesToGenerate = new Set(leaf.files);
    const generatedFiles = new Set<string>();

    // Send the initial prompt
    logger.log({
        timestamp: new Date().toISOString(),
        type: 'ai_call',
        leafPath: leaf.path,
        details: { prompt: initialPrompt, type: 'initial_prompt' },
    });

    let result = await chat.sendMessage(initialPrompt);

    // Continue the chat until all files listed in 'leaf.files' are successfully written.
    let attempts = 0;
    const MAX_ATTEMPTS = 10; // Prevent infinite loops in case the model gets stuck

    while (generatedFiles.size < filesToGenerate.size && attempts < MAX_ATTEMPTS) {
        attempts++;
        const response = result.response;
        const toolCalls = response.toolCalls();

        if (toolCalls && toolCalls.length > 0) {
            const toolOutputs: any[] = [];
            let madeProgressInThisTurn = false;

            for (const call of toolCalls) {
                if (call.function.name === 'write_file') {
                    const { path: filePath, content } = call.function.args;

                    // Basic validation for tool arguments
                    if (!filePath || typeof filePath !== 'string' || !content || typeof content !== 'string') {
                        const errorMsg = `Invalid arguments for write_file: path=${filePath}, content=${content}`;
                        console.error(errorMsg);
                        toolOutputs.push({
                            toolCode: {
                                name: 'write_file',
                                args: call.function.args,
                                output: { error: errorMsg }
                            }
                        });
                        continue;
                    }

                    // The 'write_file' tool should write the content to 'outputDir/leaf.outputPath/path'.
                    const fullPath = path.join(outputDir, leaf.outputPath, filePath);
                    const dirPath = path.dirname(fullPath);

                    try {
                        // Ensure the directory exists before writing the file
                        await Bun.mkdir(dirPath, { recursive: true });
                        await Bun.write(fullPath, content);

                        // Track generated files
                        if (!generatedFiles.has(filePath)) {
                            generatedFiles.add(filePath);
                            madeProgressInThisTurn = true;
                        }

                        // Log each file write to the 'logger'.
                        logger.log({
                            timestamp: new Date().toISOString(),
                            type: 'file_write',
                            leafPath: leaf.path,
                            details: { filePath, fullPath, size: content.length },
                        });

                        toolOutputs.push({
                            toolCode: {
                                name: 'write_file',
                                args: call.function.args,
                                output: { status: 'success', path: fullPath, size: content.length }
                            }
                        });
                    } catch (error: any) {
                        console.error(`Error writing file ${fullPath}:`, error);
                        toolOutputs.push({
                            toolCode: {
                                name: 'write_file',
                                args: call.function.args,
                                output: { status: 'failed', error: error.message }
                            }
                        });
                    }
                } else {
                    // Handle unexpected tool calls
                    console.warn(`Unexpected tool call: ${call.function.name}`);
                    toolOutputs.push({
                        toolCode: {
                            name: call.function.name,
                            args: call.function.args,
                            output: { status: 'failed', error: 'Unexpected tool call' }
                        }
                    });
                }
            }

            // Send tool outputs back to the model to continue the conversation
            if (toolOutputs.length > 0) {
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'ai_call',
                    leafPath: leaf.path,
                    details: { type: 'tool_outputs', outputs: toolOutputs },
                });
                result = await chat.sendMessage(toolOutputs);
            } else if (!madeProgressInThisTurn) {
                // If tool calls were made but no files were written or progress was made,
                // it might be stuck. Break to prevent an infinite loop.
                console.warn("Model made tool calls but no progress was made in file generation.");
                break;
            }

        } else {
            // If the model responds without tool calls, it might be done or stuck.
            if (generatedFiles.size < filesToGenerate.size) {
                // If not all files are generated, prompt the model again.
                const remainingFiles = Array.from(filesToGenerate).filter(f => !generatedFiles.has(f));
                const followUpPrompt = `Please continue generating the remaining files: ${remainingFiles.join(', ')}. Use the write_file tool.`;
                logger.log({
                    timestamp: new Date().toISOString(),
                    type: 'ai_call',
                    leafPath: leaf.path,
                    details: { prompt: followUpPrompt, type: 'follow_up_prompt' },
                });
                result = await chat.sendMessage(followUpPrompt);
            } else {
                // All files generated, and model didn't make more tool calls.
                break;
            }
        }
    }

    // Final check to ensure all files were generated
    if (generatedFiles.size < filesToGenerate.size) {
        const unwrittenFiles = Array.from(filesToGenerate).filter(f => !generatedFiles.has(f));
        logger.log({
            timestamp: new Date().toISOString(),
            type: 'ai_call',
            leafPath: leaf.path,
            details: { status: 'failed', reason: 'Not all files were generated', unwrittenFiles, attemptsMade: attempts },
        });
        throw new Error(`Not all files were generated after ${attempts} attempts. Missing: ${unwrittenFiles.join(', ')}`);
    }

    logger.log({
        timestamp: new Date().toISOString(),
        type: 'ai_call',
        leafPath: leaf.path,
        details: { status: 'success', message: 'All files generated successfully', attemptsMade: attempts },
    });
}
