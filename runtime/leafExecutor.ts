import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { logAICall } from './logger';

interface LeafConfig {
  commands?: string[];
  files: string[];
  prompt: string;
}

interface LeafExecutionResult {
  leafPath: string;
  success: boolean;
  message: string;
  error?: any;
}

// Placeholder for AI generation. In a real scenario, this would call an actual AI API.
async function simulateAIGeneration(prompt: string): Promise<string> {
  console.log(`[LeafExecutor] Simulating AI generation for prompt: ${prompt.substring(0, 100)}...`);
  // Simulate a delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  return `// Generated by AI based on prompt:\n/*\n${prompt}\n*/\n\nconsole.log(\"Hello from AI-generated code!\");\n`;
}

async function runCommand(command: string, cwd: string): Promise<void> {
  return new Promise((resolve, reject) => {
    console.log(`[LeafExecutor] Running command: '${command}' in '${cwd}'`);
    // IMPORTANT: In a production system, commands should be whitelisted and carefully sanitized
    // to prevent arbitrary code execution vulnerabilities.
    exec(command, { cwd }, (error, stdout, stderr) => {
      if (error) {
        console.error(`[LeafExecutor] Command failed: ${command}\nError: ${error.message}\nStderr: ${stderr}`);
        return reject(new Error(`Command '${command}' failed: ${error.message}`));
      }
      if (stdout) {
        console.log(`[LeafExecutor] Command stdout:\n${stdout}`);
      }
      if (stderr) {
        console.warn(`[LeafExecutor] Command stderr:\n${stderr}`);
      }
      resolve();
    });
  });
}

export async function executeLeaf(leafJsonPath: string): Promise<LeafExecutionResult> {
  const leafDir = path.dirname(leafJsonPath);
  const leafName = path.basename(leafDir);
  let config: LeafConfig | undefined;
  let generatedContent: string = '';
  const generatedFilesLog: { fileName: string; contentPreview: string }[] = [];
  let success = false;
  let errorMessage: string | undefined;

  console.log(`[LeafExecutor] Starting execution for leaf: ${leafJsonPath}`);

  try {
    // 1. Read Leaf Configuration
    const configFileContent = await fs.readFile(leafJsonPath, 'utf8');
    config = JSON.parse(configFileContent) as LeafConfig;

    // 2. Execute Commands
    if (config.commands && config.commands.length > 0) {
      for (const command of config.commands) {
        await runCommand(command, leafDir);
      }
    }

    // 3. Simulate AI Generation
    generatedContent = await simulateAIGeneration(config.prompt);

    // 4. Write Generated Files
    for (const fileName of config.files) {
      const filePath = path.join(leafDir, fileName);
      await fs.mkdir(path.dirname(filePath), { recursive: true }); // Ensure directory exists
      await fs.writeFile(filePath, generatedContent, 'utf8');
      generatedFilesLog.push({ fileName, contentPreview: generatedContent.substring(0, 200) + '...' });
      console.log(`[LeafExecutor] Generated file: ${filePath}`);
    }

    success = true;
    console.log(`[LeafExecutor] Successfully executed leaf: ${leafJsonPath}`);

  } catch (error: any) {
    success = false;
    errorMessage = error.message || 'An unknown error occurred';
    console.error(`[LeafExecutor] Error executing leaf ${leafJsonPath}:`, error);
  } finally {
    // 5. Log AI Calls
    await logAICall({
      timestamp: new Date().toISOString(),
      leafPath: leafJsonPath,
      prompt: config?.prompt || 'N/A',
      generatedFiles: generatedFilesLog,
      success: success,
      error: errorMessage,
    });
  }

  return {
    leafPath: leafJsonPath,
    success: success,
    message: success ? `Leaf '${leafName}' executed successfully.` : `Leaf '${leafName}' failed: ${errorMessage}`,
    error: errorMessage,
  };
}
