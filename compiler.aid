compiler {
  path=src/compiler;
  
  Processes .aid files into the project directory structure.
  
  The compiled tree consists of .gen.aid nodes and .leaf.json leaves.
  
  Concepts:
  
  Nodes are responsible for generating interfaces, and planning work to be done in parallel by children they spawn.
    We generate interfaces first so that work can be parallelized - that's the core of the tool.
    Nodes can spawn other nodes with gen_node, or create leaves with gen_leaf when the task is small enough to be zero-shot by an AI.
  
  Nodes are akin to typical packages/modules/functions. Leaves are closer to primitive operations, like "implement an in-memory cache with these signatures and behaviours" - instructions you could give to a junior developer with confidence the task is well-defined enough they won't mess it up.
  
  Each leaf is a .leaf.json file containing: prompt (instructions), files (what to create), commands (shell commands to run).
    The prompt contains all relevant instructions from the parent, including interfaces to adhere to.
    A lightweight process during compilation checks that no 2 leaves write to the same file.
  
  Each node and leaf has its own folder not shared by others.
    The parent defines clear interfaces for children, enabling parallelization and tree-diffing.
  
  Exports a compile function that takes rootFile, outputDir, and apiKey.
  First runs the resolver, then the llmCompiler.

  parser {
    path=src/compiler/parser.ts;
    
    Deterministic parser for .aid syntax. No LLM involved.
    Used by both resolver and compiler phases.
    
    Exports parse and stringify functions, plus type definitions for the AST nodes.

    Syntax to handle:
      include path; statements - can be local .aid file or https link
      name { content } blocks define named modules
      name=value; defines parameters
      Everything else is prose
      Code blocks (triple backticks) are opaque prose, not parsed inside
  }

  resolver {
    path=src/compiler/resolver.ts;

    Deterministic pre-processing of human-written .aid files. No LLM involved.
    Our tool never modifies human-written files - they are the source code.
    
    Exports a resolve function that takes rootFile and outputDir.
    
    This phase:
      1. Reads the root .aid file
      2. Recursively resolves all include statements
      3. For non-.aid includes, wraps content as prose
      4. Outputs resolved content to the output directory
  }

  llmCompiler {
    path=src/compiler/llmCompiler.ts;

    LLM-powered compilation of resolved .aid into nodes and leaves.
    
    Every node is a planner for its subtree. The root node takes extra care:
      - It sees the raw human spec with all its ambiguity
      - It must establish stable module boundaries matching the human's intent
      - Its structure determines how well tree diffing works downstream
    
    When processing any node:
      1. Parse the .aid content
      2. Send to LLM with system prompt explaining the format
      3. LLM uses tools: gen_node (spawn child), gen_leaf (create leaf)
      4. Recursively compile child nodes
    
    Temperature=0 for deterministic output.
    
    Encapsulation: each node fully encapsulates its children's context.
      When spawning a child, parent provides the child's spec plus relevant sibling interfaces.
      The child cannot see parent's full spec or sibling implementations.
      This isolation enables parallel compilation and stable tree diffing.
    
    Exports a compileNode function that takes the resolved aid path and apiKey.
  }

  treeDiff {
    path=src/compiler/treeDiff.ts;

    Caching via content hashing to skip unchanged subtrees.
    
    Goal: if a developer changes one line in root.aid, only affected branches recompile.
    
    Diffing happens at module boundaries. When parent changes, we compare each child's spec:
      1. Hash the content that would be passed to each gen_node/gen_leaf call
      2. Compare to hash stored in existing output
      3. If unchanged, skip that subtree
      4. If changed, prune and recompile only that subtree
    
    Exports functions for hashing content, loading/saving previous hashes, and pruning branches.
  }
}
