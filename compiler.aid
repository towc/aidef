compiler {
  path=src/compiler;
  
  Processes .aid files into the project directory structure.
  
  The compiled tree consists of .gen.aid nodes and .leaf.json leaves.
  
  Concepts:
  
  Human .aid files are ABSTRACT - high-level prose describing intent.
  The compiler's job is to transform abstract prose into CONCRETE .gen.aid specifications.
  This transformation is the core value proposition of aidef.
  
  Nodes are responsible for generating interfaces, and planning work to be done in parallel by children they spawn.
    We generate interfaces first so that work can be parallelized - that's the core of the tool.
    Nodes can spawn other nodes with gen_node, or create leaves with gen_leaf when the task is small enough to be zero-shot by an AI.
  
  Nodes are akin to typical packages/modules/functions. Leaves are closer to primitive operations, like "implement an in-memory cache with these signatures and behaviours" - instructions you could give to a junior developer with confidence the task is well-defined enough they won't mess it up.
  
  Each leaf is a .leaf.json file containing: prompt, outputPath, files, commands, sourceAid.
    prompt: instructions for code generation, including interfaces to implement.
    outputPath: where files should be written, relative to project root (from path= inheritance).
    files: list of files to create (just filenames, written to outputPath).
    commands: shell commands to run (must be whitelisted).
    sourceAid: path to the original human .aid file this leaf came from (for generated file headers).
    A lightweight process during compilation checks that no 2 leaves write to the same file.
  
  Path inheritance:
    The path= param on a module sets the base output path.
    Children inherit from parent: if compiler has path=src/compiler and parser is a child, parser's outputPath is src/compiler (and its files go there).
    Submodules do NOT repeat the full path - they inherit from parent.
    The root node should spawn an initial setup leaf that runs bun init to create the project structure.
  
  Each node and leaf has its own folder in the compilation output, but files are written to outputPath locations.
    This is possible because the parent needs to implement a clear interface for the children, and that parent can spawn a leaf to import from the other children, as decided by the interface (no runtime reading of other files).
    It's important to do it this way to minimize drift from the original developer plans, ensure good parallelization, and enable tree-diffing.
  
  Creates index.ts which exports a compile function taking rootFile, outputDir, and apiKey.
  
  The compile function:
    1. Creates a Resolver and calls resolve(rootFile, outputDir) to get the resolved .aid path
    2. Creates a GenCompiler with apiKey and calls compile(resolvedAidPath)

  parser {
    Deterministic parser for .aid syntax. No LLM involved.
    Creates parser.ts.
    
    Exports:
      - AidNode type union: AidModule | AidParam | AidInclude | AidProse
      - AidModule: { type: 'module', name: string, content: AidNode[] }
      - AidParam: { type: 'param', name: string, value: string }
      - AidInclude: { type: 'include', path: string }
      - AidProse: { type: 'prose', text: string }
      - parse(content: string): AidNode[]
      - stringify(nodes: AidNode[]): string
    
    Parsing rules:
      - "include path;" -> AidInclude (path can be local file or https URL)
      - "name { ... }" -> AidModule (recursively parse content)
      - "name=value;" -> AidParam
      - Everything else -> AidProse
      - Triple backtick code blocks are treated as opaque prose (don't parse inside)
  }

  resolver {
    Deterministic pre-processing of human-written .aid files. No LLM involved.
    Creates resolver.ts.
    
    Exports:
      - Resolver class with resolve(rootFile: string, outputDir: string): Promise<string>
      - The resolve method returns the path to the resolved .aid file
    
    Implementation:
      1. Read the root .aid file using Bun.file()
      2. Use the parser (import { parse } from './parser') to get AST
      3. Recursively resolve include statements:
         - Local .aid files: read and parse, inline content
         - https links: fetch and inline as prose
      4. Write resolved content to outputDir/root.resolved.aid
      5. Return the path to the resolved file
  }

  gen {
    LLM-powered compilation of resolved .aid into nodes and leaves.
    Creates gen.ts.
    
    Uses Google Gemini for LLM calls.
    
    Exports GenCompiler class with compile(genAidPath: string, depth?: number) method.
    Constructor takes apiKey string.
    
    The compile method:
      1. Reads the .gen.aid file content
      2. If previous content exists, use LLM to judge semantic equivalence (via TreeDiffer)
         If equivalent, skip this entire subtree - keep existing children
         If different, continue to step 3
      3. Process with LLM to spawn children (gen_node and gen_leaf tools)
      4. For each child spawned, recurse - the child's new spec will be compared to its previous content
      5. Save content for future diffing
    
    LLM tools:
      - gen_node: { name: string, content: string } - creates child directory with node.gen.aid
      - gen_leaf: { name: string, outputPath: string, sourceAid: string, prompt: string, files: string[], commands?: string[] }
    
    The system prompt is CRITICAL. It must instruct the LLM to:
      - Act as an architect that decomposes specs into nodes/leaves
      - TRANSFORM abstract human prose into CONCRETE TypeScript interfaces
        Human .aid files should NOT need to specify exact function signatures.
        The compiler figures out appropriate interfaces from context.
      - Understand that children are ISOLATED - they only see what the parent passes.
        This means passing FULL interface definitions, not just import statements.
        If a child needs to access node.path, the parent must define the interface with path field.
      - Understand path inheritance: path= sets output location, children inherit it
      - Files array contains only filenames, not paths
      - Encapsulation: each .gen.aid node is self-contained with all needed context
    
    Handle tool calls in a loop until no more function calls.
    Use temperature=0 for deterministic output.
    Track created children per directory to prevent duplicates.
    Track file collisions across leaves.
  }

  diff {
    Tree diffing to avoid unnecessary inferences during compilation.
    Creates diff.ts.
    
    When compiling, if we have the previous compiled .gen.aid content, we can avoid going deeper into that branch by checking whether the new .gen.aid content is for all practical purposes equivalent, with no deviations.
    If it is the same, then we can keep it and all of its children, and don't need to recurse further as we'd expect the output to be the same.
    
    The comparison uses LLM judgement for semantic equivalence - the new spec might use different words but mean the same thing.
    A synonym or minor rephrasing shouldn't trigger recompilation if the meaning is unchanged.
    
    If the tree diff shows there would be some change, we recompile that node, which produces new child specs.
    For each child, we recursively apply the same semantic comparison.
    
    This is why we want generated nodes to be predictable (temperature=0) and heavily encapsulated - to minimize spurious differences and enable effective tree diffing.
    We want the cycle of "user makes change to code -> user sees effect of change" to be as fast as possible.
    
    Exports:
      - TreeDiffer class with methods for loading/saving previous content and semantic comparison
  }
}
