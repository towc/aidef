compiler {
  path=src/compiler;
  
  Processes .aid files into the project directory structure.
  
  The compiled tree consists of .gen.aid nodes and .leaf.json leaves.
  
  Concepts:
  
  Nodes are responsible for generating interfaces, and planning work to be done in parallel by children they spawn.
    We generate interfaces first so that work can be parallelized - that's the core of the tool.
    Nodes can spawn other nodes with gen_node, or create leaves with gen_leaf when the task is small enough to be zero-shot by an AI.
  
  Nodes are akin to typical packages/modules/functions. Leaves are closer to primitive operations, like "implement an in-memory cache with these signatures and behaviours" - instructions you could give to a junior developer with confidence the task is well-defined enough they won't mess it up.
  
  Each leaf is a .leaf.json file containing: prompt, outputPath, files, commands, sourceAid.
    prompt: instructions for code generation, including interfaces to implement.
    outputPath: where files should be written, relative to project root (from path= inheritance).
    files: list of files to create (just filenames, written to outputPath).
    commands: shell commands to run (must be whitelisted).
    sourceAid: path to the original human .aid file this leaf came from (for generated file headers).
    A lightweight process during compilation checks that no 2 leaves write to the same file.
  
  Path inheritance:
    The path= param on a module sets the base output path.
    Children inherit from parent: if compiler has path=src/compiler and parser is a child, parser's outputPath is src/compiler (and its files go there).
    Submodules do NOT repeat the full path - they inherit from parent.
    The root node should spawn an initial setup leaf that runs bun init to create the project structure.
  
  Each node and leaf has its own folder in the compilation output, but files are written to outputPath locations.
  
  Exports a compile function that takes rootFile, outputDir, and apiKey.
  First runs the resolver, then the llmCompiler.

  parser {
    Deterministic parser for .aid syntax. No LLM involved.
    Used by both resolver and compiler phases.
    
    Exports parse and stringify functions, plus type definitions for the AST nodes.

    Syntax to handle:
      include path; statements - can be local .aid file or https link
      name { content } blocks define named modules
      name=value; defines parameters
      Everything else is prose
      Code blocks (triple backticks) are opaque prose, not parsed inside
  }

  resolver {
    Deterministic pre-processing of human-written .aid files. No LLM involved.
    Our tool never modifies human-written files - they are the source code.
    
    Exports a resolve function that takes rootFile and outputDir.
    
    This phase:
      1. Reads the root .aid file
      2. Recursively resolves all include statements
      3. For non-.aid includes, wraps content as prose
      4. Outputs resolved content to the output directory
  }

  llmCompiler {
    LLM-powered compilation of resolved .aid into nodes and leaves.
    
    Every node is a planner for its subtree. The root node takes extra care:
      - It sees the raw human spec with all its ambiguity
      - It must establish stable module boundaries matching the human's intent
      - Its structure determines how well tree diffing works downstream
      - It should create an initial setup leaf that runs bun init to set up the project
    
    When processing any node:
      1. Parse the .aid content to find modules and their path= params
      2. Track the current outputPath (inherited from parent or set by path=)
      3. Send to LLM with system prompt explaining the format
      4. LLM uses tools: gen_node (spawn child node), gen_leaf (create leaf)
      5. Pass outputPath to children so they know where their files go
      6. Recursively compile child nodes
    
    gen_leaf tool requires: name, outputPath, prompt, files, and optionally commands.
    gen_node tool requires: name, content, and the parent's outputPath for inheritance.
    
    Temperature=0 for deterministic output.
    
    Encapsulation: each node fully encapsulates its children's context.
      When spawning a child, parent provides the child's spec plus relevant sibling interfaces.
      The child cannot see parent's full spec or sibling implementations.
      This isolation enables parallel compilation and stable tree diffing.
    
    Exports a compileNode function that takes the resolved aid path and apiKey.
  }

  treeDiff {
    Caching via content hashing to skip unchanged subtrees.
    
    Goal: if a developer changes one line in root.aid, only affected branches recompile.
    
    Diffing happens at module boundaries. When parent changes, we compare each child's spec:
      1. Hash the content that would be passed to each gen_node/gen_leaf call
      2. Compare to hash stored in existing output
      3. If unchanged, skip that subtree
      4. If changed, prune and recompile only that subtree
    
    Exports functions for hashing content, loading/saving previous hashes, and pruning branches.
  }
}
