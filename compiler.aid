compiler {
  path=src/compiler;
  
  Processes .aid files into the project directory structure.
  
  The compiled tree consists of .gen.aid nodes and .leaf.json leaves.
  
  Concepts:
  
  Nodes are responsible for generating interfaces, and planning work to be done in parallel by children they spawn.
    We generate interfaces first so that work can be parallelized - that's the core of the tool.
    Nodes can spawn other nodes with gen_node, or create leaves with gen_leaf when the task is small enough to be zero-shot by an AI.
  
  Nodes are akin to typical packages/modules/functions. Leaves are closer to primitive operations, like "implement an in-memory cache with these signatures and behaviours" - instructions you could give to a junior developer with confidence the task is well-defined enough they won't mess it up.
  
  Each leaf is a .leaf.json file containing: prompt, outputPath, files, commands, sourceAid.
    prompt: instructions for code generation, including interfaces to implement.
    outputPath: where files should be written, relative to project root (from path= inheritance).
    files: list of files to create (just filenames, written to outputPath).
    commands: shell commands to run (must be whitelisted).
    sourceAid: path to the original human .aid file this leaf came from (for generated file headers).
    A lightweight process during compilation checks that no 2 leaves write to the same file.
  
  Path inheritance:
    The path= param on a module sets the base output path.
    Children inherit from parent: if compiler has path=src/compiler and parser is a child, parser's outputPath is src/compiler (and its files go there).
    Submodules do NOT repeat the full path - they inherit from parent.
    The root node should spawn an initial setup leaf that runs bun init to create the project structure.
  
  Each node and leaf has its own folder in the compilation output, but files are written to outputPath locations.
  
  Creates index.ts which exports:
    export async function compile(rootFile: string, outputDir: string, apiKey: string): Promise<void>
  
  The compile function:
    1. Creates a Resolver (from ./resolver) and calls resolve(rootFile, outputDir) to get the resolved .aid path
    2. Creates a GenCompiler (from ./gen) with apiKey and calls compile(resolvedAidPath)

  parser {
    Deterministic parser for .aid syntax. No LLM involved.
    Creates parser.ts.
    
    Exports:
      - AidNode type union: AidModule | AidParam | AidInclude | AidProse
      - AidModule: { type: 'module', name: string, content: AidNode[] }
      - AidParam: { type: 'param', name: string, value: string }
      - AidInclude: { type: 'include', path: string }
      - AidProse: { type: 'prose', text: string }
      - parse(content: string): AidNode[]
      - stringify(nodes: AidNode[]): string
    
    Parsing rules:
      - "include path;" -> AidInclude (path can be local file or https URL)
      - "name { ... }" -> AidModule (recursively parse content)
      - "name=value;" -> AidParam
      - Everything else -> AidProse
      - Triple backtick code blocks are treated as opaque prose (don't parse inside)
  }

  resolver {
    Deterministic pre-processing of human-written .aid files. No LLM involved.
    Creates resolver.ts.
    
    Exports:
      - Resolver class with resolve(rootFile: string, outputDir: string): Promise<string>
      - The resolve method returns the path to the resolved .aid file
    
    Implementation:
      1. Read the root .aid file using Bun.file()
      2. Use the parser (import { parse } from './parser') to get AST
      3. Recursively resolve include statements:
         - Local .aid files: read and parse, inline content
         - https links: fetch and inline as prose
      4. Write resolved content to outputDir/root.resolved.aid
      5. Return the path to the resolved file
  }

  gen {
    LLM-powered compilation of resolved .aid into nodes and leaves.
    Creates gen.ts.
    
    Dependencies (use exact package names):
    ```
    import { GoogleGenAI, Type } from '@google/genai';
    ```
    
    Exports:
      - GenCompiler class with compile(genAidPath: string, depth?: number) method
    
    Constructor takes apiKey string, creates GoogleGenAI instance:
    ```
    this.ai = new GoogleGenAI({ apiKey });
    ```
    
    The compile method:
      1. Reads the .gen.aid file content using fs.readFileSync
      2. Checks tree diff - skip if unchanged (use TreeDiffer from ./diff)
      3. If changed, prune old branch first
      4. Process with LLM using ai.chats.create then chat.sendMessage
      5. Save content for future diffing
    
    LLM tools to define (use Type from @google/genai for schema):
      - gen_node: { name: string, content: string } - creates child directory with node.gen.aid
      - gen_leaf: { name: string, outputPath: string, sourceAid: string, prompt: string, files: string[], commands?: string[] }
    
    System prompt should explain:
      - You are an architect that decomposes specs into nodes/leaves
      - Transform abstract prose into concrete TypeScript interfaces
      - path= param sets output location, children inherit it
      - Files array contains only filenames, not paths
    
    Handle tool calls in a loop:
      - Get response.functionCalls
      - For gen_node: create directory, write node.gen.aid, recursively compile
      - For gen_leaf: create directory, write leaf.gen.aid.leaf.json
      - Send functionResponse back to LLM
      - Continue until no more function calls
    
    Use temperature=0 for deterministic output.
    Track created children per directory to prevent duplicates.
    Track file collisions across leaves.
  }

  diff {
    Caching via content comparison to skip unchanged subtrees.
    Creates diff.ts.
    
    Exports:
      - TreeDiffer class with methods:
        - loadPrevious(genAidPath: string): string | null - reads .prev file if exists
        - savePrevious(genAidPath: string, content: string): void - writes .prev file
        - isUnchanged(previous: string, current: string): boolean - compares content
        - pruneBranch(nodeDir: string): void - deletes child directories
    
    Implementation:
      - .prev files store previous content next to .gen.aid files
      - isUnchanged does simple string comparison
      - pruneBranch uses fs.rmSync with recursive option
  }
}
