compiler {
  path=src/compiler;
  
  Processes .aid files into the project directory structure.
  
  The compiled tree consists of .gen.aid nodes and .leaf.json leaves.
  
  CRITICAL CODE GENERATION RULES (applies to ALL modules in compiler):
  - NEVER use ambient declarations like "export const X: Type;" or "export function f(): void;"
  - Ambient declarations are for .d.ts files only, NOT implementation files
  - When you import something, use it directly - do NOT re-export or redeclare it
  - Only declare/export things you are IMPLEMENTING in this file
  - If the prompt shows interfaces for understanding, implement them OR import them - never stub them
  - If a function uses "await", it MUST be declared with "async"
  - If a function returns Promise, it MUST be declared with "async"
  
  Concepts:
  
  Human .aid files are ABSTRACT - high-level prose describing intent.
  The compiler's job is to transform abstract prose into CONCRETE .gen.aid specifications.
  This transformation is the core value proposition of aidef.
  
  Nodes are responsible for generating interfaces, and planning work to be done in parallel by children they spawn.
    We generate interfaces first so that work can be parallelized - that's the core of the tool.
    Nodes can spawn other nodes with gen_node, or create leaves with gen_leaf when the task is small enough to be zero-shot by an AI.
  
  Nodes are akin to typical packages/modules/functions. Leaves are closer to primitive operations, like "implement an in-memory cache with these signatures and behaviours" - instructions you could give to a junior developer with confidence the task is well-defined enough they won't mess it up.
  
  Each leaf is a .leaf.json file containing: prompt, outputPath, files, commands, sourceAid.
    prompt: instructions for code generation, including interfaces to implement.
    outputPath: where files should be written, relative to project root (from path= inheritance).
    files: list of files to create (just filenames, written to outputPath).
    commands: shell commands to run (must be whitelisted).
    sourceAid: path to the original human .aid file this leaf came from (for generated file headers).
    A lightweight process during compilation checks that no 2 leaves write to the same file.
  
  Path inheritance:
    The path= param on a module sets the base output path.
    Children inherit from parent: if compiler has path=src/compiler and parser is a child, parser's outputPath is src/compiler (and its files go there).
    Submodules do NOT repeat the full path - they inherit from parent.
    The root node should spawn an initial setup leaf that runs bun init to create the project structure.
  
  Each node and leaf has its own folder in the compilation output, but files are written to outputPath locations.
    This is possible because the parent needs to implement a clear interface for the children, and that parent can spawn a leaf to import from the other children, as decided by the interface (no runtime reading of other files).
    It's important to do it this way to minimize drift from the original developer plans, ensure good parallelization, and enable tree-diffing.
  
  Module scope:
    Each module { } block defines a SCOPE. A node should ONLY create children for modules that are DIRECTLY nested inside it.
    If module A contains module B, and module B contains module C:
      - The node for A should create a child for B (gen_node or gen_leaf)
      - The node for A should NOT create children for C - that's B's responsibility
    This ensures proper encapsulation and prevents duplicate/conflicting outputs.
    A module's path= applies to that module and its children, not to sibling or parent modules.
  
  Creates index.ts which exports a compile function taking rootFile, outputDir, and apiKey.
  
  The compile function:
    1. Creates a compile logger via createCompileLogger(outputDir)
    2. Creates a Resolver and calls resolve(rootFile, outputDir) to get the resolved .aid path
    3. Creates a GenCompiler with apiKey and logger, calls compile(resolvedAidPath)
    4. Closes the logger when done (even on error, use try/finally)
  
  IMPORTANT for index.ts: Import symbols from sibling modules (parser, resolver, gen, logger, diff).
  Do NOT redeclare those imported types/functions - just use them directly.
  Only DEFINE types/interfaces that are NEW to this module.

  parser {
    Deterministic parser for .aid syntax. No LLM involved.
    Creates parser.ts.
    
    Exports:
      - AidNode type union: AidModule | AidParam | AidInclude | AidProse
      - AidModule: { type: 'module', name: string, content: AidNode[] }
      - AidParam: { type: 'param', name: string, value: string }
      - AidInclude: { type: 'include', path: string }
      - AidProse: { type: 'prose', text: string }
      - parse(content: string): AidNode[]
      - stringify(nodes: AidNode[]): string
    
    Parsing rules:
      - "include path;" -> AidInclude (path can be local file or https URL)
        IMPORTANT: The semicolon is the TERMINATOR, NOT part of the path.
        Example: the statement "inc-lude foo.aid;" (without the hyphen) should produce path='foo.aid' (no semicolon in path!)
      - "name { ... }" -> AidModule (recursively parse content)
        Module name is the identifier before the opening brace, content is recursively parsed
      - "name=value;" -> AidParam
        The semicolon is the terminator, not part of the value
      - Everything else -> AidProse
      - Triple backtick code blocks are treated as opaque prose (don't parse inside)
  }

  resolver {
    Deterministic pre-processing of human-written .aid files. No LLM involved.
    Creates resolver.ts.
    
    Exports:
      - Resolver class with resolve(rootFile: string, outputDir: string): Promise<string>
      - The resolve method returns the path to the resolved .aid file
      - Re-exports parse function from parser (export { parse } from './parser')
      - Re-exports types from parser (export type { AidNode, AidModule, ... } from './parser')
        IMPORTANT: Use 'export type' for type re-exports to work with verbatimModuleSyntax
    
    Implementation:
      1. Read the root .aid file using Bun.file()
      2. Use the parser (import { parse } from './parser') to get AST
      3. Recursively resolve include statements:
         - Local .aid files: read and parse, inline content
         - https links: fetch and inline as prose
      4. Write resolved content to outputDir/root.resolved.aid
      5. Return the path to the resolved file
  }

  gen {
    LLM-powered compilation of resolved .aid into nodes and leaves.
    Creates gen.ts.
    
    Uses Google Gemini via @google/genai package (GoogleGenAI class, NOT @google/generative-ai).
    
    File system operations: use fs from 'node:fs/promises' for mkdir, readFile, etc.
    Do NOT use Bun.mkdir or other non-existent Bun APIs.
    Use Bun.file() for reading files, and Bun.write() for writing files.
    Use fs.mkdir(path, { recursive: true }) for creating directories.
    
    CRITICAL API PATTERN - use EXACTLY this code:
    ```typescript
    import { GoogleGenAI, Type } from '@google/genai';
    const genai = new GoogleGenAI({ apiKey });
    const response = await genai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      config: { 
        temperature: 0,
        tools: [{ functionDeclarations: [...] }]  // tools MUST be inside config!
      }
    });
    // response.functionCalls = array of {name, args} or undefined
    // response.text = string response or undefined
    ```
    IMPORTANT: tools MUST be inside config object, NOT at the top level.
    NEVER use getGenerativeModel(), model.startChat(), or @google/generative-ai patterns.
    
    Exports GenCompiler class with compile(genAidPath: string, depth?: number) method.
    Constructor takes apiKey string and optional logger (from ./logger).
    If logger is provided, log all pass results, tool calls, and validation events.
    
    Multi-Pass Compilation:
      The compile method uses THREE PASSES to ensure reliable child generation:
      
      PASS 1 - Planning:
        Ask the LLM to analyze the .aid content and produce a structured plan.
        The plan should identify:
          - What modules are DIRECTLY nested (not deeply nested)
          - For each module: is it a node (needs further decomposition) or a leaf (small enough for zero-shot)?
          - What interfaces need to be defined for children to implement
        Output: A text plan listing expected children with their types (node vs leaf).
      
      PASS 2 - Interface Definition:
        Based on the plan, ask the LLM to define CONCRETE TypeScript interfaces.
        For each planned child, generate:
          - Full interface definitions (not just import statements)
          - Clear contracts that children must implement
          - Any shared types needed across children
        Output: A text block with all interface definitions.
      
      PASS 3 - Child Generation:
        Now ask the LLM to generate children using tool calls (gen_node, gen_leaf).
        The prompt includes the plan and interfaces from passes 1-2.
        
        IMPORTANT: Before calling the LLM, DETERMINISTICALLY extract expected modules from the .aid content.
        Use a function extractTopLevelModules(content: string): string[] that finds all module blocks
        at the TOP LEVEL of the content (not nested inside other blocks). This is done by:
        1. Remove code blocks to avoid false positives
        2. Find patterns like "identifier followed by opening brace" at the START of lines
        3. Track brace depth - only include modules where the opening brace is at depth 0
        4. Filter out common prose words (if, for, while, function, class, etc.)
        
        After receiving tool calls from the LLM, VALIDATE against these expected modules:
          - If an expected module is missing: log "MISSING CHILD: <name>" and retry
          - If a duplicate is created: log "DUPLICATE CHILD: <name>" and skip
          - If a child doesn't match any expected module: allow it (might be an index entry point)
        Retry up to 3 times if any expected modules are missing.
    
    The compile method overall:
      1. Reads the .gen.aid file content
      2. If previous content exists, use LLM to judge semantic equivalence (via TreeDiffer)
         If equivalent, skip this entire subtree - keep existing children
         If different, continue to step 3
      3. Execute the three-pass compilation (Planning → Interfaces → Generation)
      4. For each child spawned, recurse - the child's new spec will be compared to its previous content
      5. Save content for future diffing
    
    LLM tools (used in Pass 3):
      - gen_node: { name: string, content: string } - creates child directory with node.gen.aid
      - gen_leaf: { name: string, outputPath: string, sourceAid: string, prompt: string, files: string[], commands?: string[] }
    
    The system prompts are CRITICAL. They must instruct the LLM to:
      - Act as an architect that decomposes specs into nodes/leaves
      - TRANSFORM abstract human prose into CONCRETE TypeScript interfaces
        Human .aid files should NOT need to specify exact function signatures.
        The compiler figures out appropriate interfaces from context.
      - Understand that children are ISOLATED - they only see what the parent passes.
        This means passing FULL interface definitions, not just import statements.
        If a child needs to access node.path, the parent must define the interface with path field.
      - Understand path inheritance: path= sets output location, children inherit it
      - Files array contains only filenames, not paths
      - Encapsulation: each .gen.aid node is self-contained with all needed context
      - RESPECT MODULE SCOPE: Only create children for modules DIRECTLY nested in the current spec.
        Do NOT create children for deeply nested modules - let the intermediate node handle those.
        If you see module A containing module B containing module C, only create a child for A.
        A's child will then handle B, and B's child will handle C.
      - NEVER DIVERGE from parent instructions. Follow them to the letter.
        When the parent spec contains specific details (package names, class names, API patterns),
        preserve them EXACTLY in child prompts. Do NOT substitute similar alternatives.
        Children cannot see the original spec - they only see what the parent passes.
        If you change or omit details, they are lost forever.
    
    Use temperature=0 for deterministic output.
    Track created children per directory to prevent duplicates.
    Track file collisions across leaves.
  }

  logger {
    Compile-time logging for debugging and analysis.
    Creates logger.ts.
    
    Stores all AI calls, pass results, and child generation events in compile.log.jsonl.
    Each line is a JSON object with timestamp, type, nodePath, and details.
    Used by analyse mode to review what happened during compilation.
    
    Log entry types:
      - 'pass1_plan': The planning pass output (expected children list)
      - 'pass2_interfaces': The interface definitions generated
      - 'pass3_start': Beginning of child generation pass
      - 'tool_call': Each gen_node or gen_leaf tool call received
      - 'validation_error': Missing/duplicate/unexpected child detected
      - 'retry': Retrying child generation due to validation failure
      - 'semantic_diff': Result of semantic equivalence check (skipped or recompiling)
      - 'node_complete': Node finished processing
      - 'error': Any errors encountered
    
    Exports (use EXACTLY these interfaces):
    ```typescript
    export interface CompileLogEntry {
      timestamp: string;
      type: string;
      nodePath: string;
      details: any;
    }
    
    export interface Logger {
      log(type: string, nodePath: string, details: any): void;
      close(): void;
    }
    
    export function createCompileLogger(outputDir: string): Logger;
    ```
    
    Implementation:
      - createCompileLogger MUST ensure outputDir exists before opening file (use mkdir -p equivalent)
      - Use fs.mkdirSync(outputDir, { recursive: true }) from 'node:fs' to create directory
      - Then open outputDir/compile.log.jsonl for appending using Bun.file().writer()
      - log() writes a JSON line with timestamp, type, nodePath, details
      - close() flushes and closes the file
  }

  diff {
    Tree diffing to avoid unnecessary inferences during compilation.
    Creates diff.ts.
    
    Uses Google Gemini via @google/genai package (GoogleGenAI class) for semantic comparison.
    
    CRITICAL API PATTERN - use EXACTLY this code:
    ```typescript
    import { GoogleGenAI } from '@google/genai';
    const genai = new GoogleGenAI({ apiKey });
    const response = await genai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: { temperature: 0 }
    });
    const text = response.text;
    ```
    NEVER use getGenerativeModel(), model.startChat(), or @google/generative-ai patterns.
    
    When compiling, if we have the previous compiled .gen.aid content, we can avoid going deeper into that branch by checking whether the new .gen.aid content is for all practical purposes equivalent, with no deviations.
    If it is the same, then we can keep it and all of its children, and don't need to recurse further as we'd expect the output to be the same.
    
    The comparison uses LLM judgement for semantic equivalence - the new spec might use different words but mean the same thing.
    A synonym or minor rephrasing shouldn't trigger recompilation if the meaning is unchanged.
    
    If the tree diff shows there would be some change, we recompile that node, which produces new child specs.
    For each child, we recursively apply the same semantic comparison.
    
    This is why we want generated nodes to be predictable (temperature=0) and heavily encapsulated - to minimize spurious differences and enable effective tree diffing.
    We want the cycle of "user makes change to code -> user sees effect of change" to be as fast as possible.
    
    Exports:
      - TreeDiffer class with methods for loading/saving previous content and semantic comparison
  }
}
