/*
  AIDef - A programming language where AI is the runtime
  
  This is AIDef's own root.aid, defining itself.
  
  Compiles .aid files into a tree of .aidg files,
  then builds code from leaf nodes. No database -
  files are the source of truth.
*/

A CLI tool that compiles .aid files into code.

// === Hard requirements ===
TypeScript strict mode !important
Bun runtime, not Node !important
No database - files are the source of truth !important
Each submodule must be independently runnable !important

// === File types ===
.aid-files {
  // User source files, CSS-like natural language
  parse with selector rules: name {}, .tag {}, etc
  resolve @imports recursively
  preserve ``` code blocks as literal prose
  strip // and /* */ comments before AI sees content
}

.aidg-files {
  // Generated nodes, same CSS-like format
  fully resolved (no imports)
  users can inspect and copy snippets back
}

.aidc-files {
  // Context for nodes, YAML format
  contains all potentially relevant info from ancestors
  context filter agent selects relevant subset
}

.aidq-files {
  // Questions/uncertainties, YAML format
  users answer via --browse or direct edit
}

// === Core architecture ===

parser {
  parse .aid file syntax
  
  lexer {
    tokenize: selectors, braces, comments, code blocks, prose
    handle nested structures
  }
  
  ast {
    build tree from tokens
    represent: modules, tags, selectors, rules, prose blocks
  }
  
  resolver {
    apply CSS specificity rules
    merge inherited context
    resolve :or(), :not(), :has() selectors
  }
  
  importer {
    resolve @path imports
    .aid files parsed with selectors
    other files (.md, .txt) inlined as plain text
  }
}

compiler {
  // Phase 1: generate .aidg tree from root.aid
  
  reads .aid files, outputs .aid-gen/ folder
  each node produces node.aidc with full context
  
  planner {
    determine which submodules to create
    identify leaf vs non-leaf nodes
    all siblings run in parallel
  }
  
  context-builder {
    gather all potentially relevant context
    output as node.aidc (YAML)
    include: interfaces, constraints, conventions, utilities
    annotate where each directive originated
  }
  
  differ {
    compare new vs existing .aidg outputs
    skip subtrees with identical interfaces
    use interface hashes for fast comparison
  }
}

generator {
  // Phase 2: execute leaf nodes to produce code
  
  context-filter {
    read node.aidc
    determine relevant subset for this generation
    // future: "skills" system triggers rules based on keywords
  }
  
  executor {
    invoke AI with filtered context + node.aidg
    output code to build/ folder
  }
  
  checks {
    // TODO: post-generation enforcement
    // verify outputs match declared interfaces
    // flag deviations for review
  }
}

cli {
  use Bun.argv for argument parsing
  
  run {
    default mode: compile .aid tree
    stream .aidq items as they appear
  }
  
  browse {
    TUI mode with --browse flag
    watch compilation progress
    browse .aidg tree structure  
    view and answer .aidq questions inline
    abort early if needed
  }
  
  build {
    --build flag: execute leaf nodes
    generate code to ./build/
    only after user approval
  }
  
  estimate {
    --estimate flag: show cost estimate
    count nodes, estimate tokens
    abort if exceeds --max-cost threshold
  }
  
  auth {
    --auth flag: TUI for LLM provider configuration
    support multiple providers: OpenAI, Anthropic, Google, local models, etc
    store credentials securely (system keychain or encrypted config)
    allow per-project overrides via .aidrc or environment
    test connection before saving
  }
}

providers {
  // LLM provider abstraction
  
  common interface for all providers
  support: OpenAI, Anthropic, Google, Ollama, OpenRouter, etc
  
  config {
    global config in ~/.config/aid/
    project config in .aidrc (gitignored)
    environment variables as fallback
    provider selection per task type (compile vs generate)
  }
  
  adapter {
    normalize request/response formats
    handle rate limiting and retries
    stream responses where supported
  }
}

questions {
  generate .aidq files (YAML) for uncertainties
  parse answered questions
  inject answers into next compilation run
}

// === Global conventions ===

:leaf {
  include unit tests
  use bun test
}

* {
  prefer Bun APIs over Node equivalents
  Bun.file over fs
  Bun.serve if HTTP needed
  Bun.$ for shell commands
}

.tui {
  consider ink or blessed
  keep it simple - progress and tree view
}
