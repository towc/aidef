aidef is a new high-level programming language that allows developers to write the source code (.aid files) of a project for an AI to build.

The point of a programming language is to translate human thoughts into unambiguous instructions.
  The more high-level a language is, the easier it is for the user, typically, but not if it's at the cost of not being able to specify details. Think about how javascript still has bitwise operators and some low-level tooling despite being a high-level language - that's one of the reasons it's so popular.
  Aidef is no different. It's the next step above transpilation: transistors <- cpu instructions <- machine code <- assembly <- low-level language <- interpreters <- high-level language <- transpilers <- aidef.
  The aidef build tool is a transpiler from .aid files into other high- or low-level languages that have deterministic runners (e.g. typescript or python or rust), but we do this carefully and cleverly to minimize AI inference costs and build times.

.aid files have a parseable syntax resembling nginx configuration, except it allows for prose.
This is the root.aid file for the aidef project - it is a good example of how .aid files look like.

This project targets typescript/bun.

The core of aidef is to have a pipeline to take these .aid files into an actionable highly parallelizable plan. We call this plan generation "compilation".

include compiler.aid;

Once everything is compiled, the developer has the option to inspect the plan and make adjustments to the human .aid files and re-compile, before executing the plan with the runtime.

include runtime.aid;

cli {
  path=src;
  
  Entry point for the aidef tool. Creates index.ts. Uses commander for arg parsing.
  
  Imports and function signatures (MUST match exactly):
  - { compile } from './compiler' - signature: compile(rootFile: string, outputDir: string, apiKey: string): Promise<void>
  - { run } from './runtime' - signature: run(outputDir: string, apiKey: string): Promise<void>
  - Gets GEMINI_API_KEY from process.env.GEMINI_API_KEY
  
  IMPORTANT: Call compile and run with POSITIONAL ARGUMENTS, not an options object.
  Example: await compile(file, outputDir, GEMINI_API_KEY)
  NOT: compile({ file, outputDir, ... })
  
  Commands:
    compile [file] - compiles the given .aid file (default: root.aid) to the output directory
    run - executes a previously compiled plan from the output directory
    analyse {
      looks at the compiled plan, the ai call logs from the compilation (and runtime if already executed), and analyses it to determine the flow of instructions via parseable .gen.aid.map files, similar to javascript source maps, indicating what line of code in the corresponding .aid file came from which line of code of which other file;
      It also looks at whether there was some miscommunication between parent and child, or whether a node took a long time to reach an answer that could have been reached much more quickly with a small hint, then records it in a .gen.aid.info file, and provides suggestions (recursively based on the .aid.map files) on which original human .aid file should be amended and how.
    }
    browse {
      a tui tool to inspect the plan files and analysis output, with options to automatically (or manually) implement them.
    }

  Options (global, defined on program before commands):
    --output, -o sets the output directory (default: /tmp/aidef-<timestamp>)
    --max-parallel limits concurrent LLM calls (default: 10)
    --max-retries for failed LLM calls (default: 3)
    --max-depth for compilation tree (default: 5)
  
  CRITICAL: Options are GLOBAL, not per-command. Inside action callbacks, use program.opts() to access them:
    const opts = program.opts();
    const outputDir = opts.output;
  DO NOT use action callback parameters for global options.
}
